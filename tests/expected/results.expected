return
function()
  return
end
function()
  return
end
define Proc(0)
L0 (entry)
	RET {L1}
L1 (exit)
return 1
function()
  return
    1
end
function()
  return
    1
end
define Proc(0)
L0 (entry)
	RET {1 Kint(0)} {L1}
L1 (exit)
return 42, 4.2, true, 'hello'
function()
  return
    42
   ,
    4.2000000000000002
   ,
    true
   ,
    'hello'
end
function()
  return
    42
   ,
    4.2000000000000002
   ,
    true
   ,
    'hello'
end
define Proc(0)
L0 (entry)
	RET {42 Kint(0), 4.200000000000 Kflt(1), true, 'hello' Ks(2)} {L1}
L1 (exit)
return a
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       a --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       a --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {a} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return 1+2
function()
  return
    --[binary expr start] any
     1
    +
     2
    --[binary expr end]
end
function()
  return
    --[binary expr start] integer
     1
    +
     2
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	ADDii {1 Kint(0), 2 Kint(1)} {Tint(0)}
	RET {Tint(0)} {L1}
L1 (exit)
return 2^3-5*4
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      2
     ^
      3
     --[binary expr end]
    -
     --[binary expr start] any
      5
     *
      4
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] number
     --[binary expr start] number
      2
     ^
      3
     --[binary expr end]
    -
     --[binary expr start] integer
      5
     *
      4
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	POW {2 Kint(0), 3 Kint(1)} {Tflt(0)}
	MULii {5 Kint(2), 4 Kint(3)} {Tint(0)}
	SUBfi {Tflt(0), Tint(0)} {Tflt(1)}
	RET {Tflt(1)} {L1}
L1 (exit)
return 1+1
function()
  return
    --[binary expr start] any
     1
    +
     1
    --[binary expr end]
end
function()
  return
    --[binary expr start] integer
     1
    +
     1
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	ADDii {1 Kint(0), 1 Kint(0)} {Tint(0)}
	RET {Tint(0)} {L1}
L1 (exit)
return 1+1+1
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      1
     +
      1
     --[binary expr end]
    +
     1
    --[binary expr end]
end
function()
  return
    --[binary expr start] integer
     --[binary expr start] integer
      1
     +
      1
     --[binary expr end]
    +
     1
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	ADDii {1 Kint(0), 1 Kint(0)} {Tint(0)}
	ADDii {Tint(0), 1 Kint(0)} {Tint(1)}
	RET {Tint(1)} {L1}
L1 (exit)
return 2-3/5*4
function()
  return
    --[binary expr start] any
     2
    -
     --[binary expr start] any
      --[binary expr start] any
       3
      /
       5
      --[binary expr end]
     *
      4
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] number
     2
    -
     --[binary expr start] number
      --[binary expr start] number
       3
      /
       5
      --[binary expr end]
     *
      4
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	DIVii {3 Kint(1), 5 Kint(2)} {Tflt(0)}
	MULfi {Tflt(0), 4 Kint(3)} {Tflt(1)}
	SUBif {2 Kint(0), Tflt(1)} {Tflt(0)}
	RET {Tflt(0)} {L1}
L1 (exit)
return 4.2//5
function()
  return
    --[binary expr start] any
     4.2000000000000002
    //
     5
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     4.2000000000000002
    //
     5
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	IDIV {4.200000000000 Kflt(0), 5 Kint(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return 0.0
function()
  return
    0.0000000000000000
end
function()
  return
    0.0000000000000000
end
define Proc(0)
L0 (entry)
	RET {0.000000000000 Kflt(0)} {L1}
L1 (exit)
return 0
function()
  return
    0
end
function()
  return
    0
end
define Proc(0)
L0 (entry)
	RET {0 Kint(0)} {L1}
L1 (exit)
return -0//1
function()
  return
    --[binary expr start] any
     --[unary expr start] any
     -
      0
     --[unary expr end]
    //
     1
    --[binary expr end]
end
function()
  return
    --[binary expr start] integer
     --[unary expr start] integer
     -
      0
     --[unary expr end]
    //
     1
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	UNMi {0 Kint(0)} {Tint(0)}
	IDIV {Tint(0), 1 Kint(1)} {Tint(1)}
	RET {Tint(1)} {L1}
L1 (exit)
return 3^-1
function()
  return
    --[binary expr start] any
     3
    ^
     --[unary expr start] any
     -
      1
     --[unary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] number
     3
    ^
     --[unary expr start] integer
     -
      1
     --[unary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	UNMi {1 Kint(1)} {Tint(0)}
	POW {3 Kint(0), Tint(0)} {Tflt(0)}
	RET {Tflt(0)} {L1}
L1 (exit)
return (1 + 1)^(50 + 50)
function()
  return
    --[binary expr start] any
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        1
       +
        1
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    ^
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        50
       +
        50
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] number
     --[suffixed expr start] integer
      --[primary start] integer
       --[binary expr start] integer
        1
       +
        1
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    ^
     --[suffixed expr start] integer
      --[primary start] integer
       --[binary expr start] integer
        50
       +
        50
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	ADDii {1 Kint(0), 1 Kint(0)} {Tint(0)}
	ADDii {50 Kint(1), 50 Kint(1)} {Tint(1)}
	POW {Tint(0), Tint(1)} {Tflt(0)}
	RET {Tflt(0)} {L1}
L1 (exit)
return (-2)^(31 - 2)
function()
  return
    --[binary expr start] any
     --[suffixed expr start] any
      --[primary start] any
       --[unary expr start] any
       -
        2
       --[unary expr end]
      --[primary end]
     --[suffixed expr end]
    ^
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        31
       -
        2
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] number
     --[suffixed expr start] integer
      --[primary start] integer
       --[unary expr start] integer
       -
        2
       --[unary expr end]
      --[primary end]
     --[suffixed expr end]
    ^
     --[suffixed expr start] integer
      --[primary start] integer
       --[binary expr start] integer
        31
       -
        2
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	UNMi {2 Kint(0)} {Tint(0)}
	SUBii {31 Kint(1), 2 Kint(0)} {Tint(1)}
	POW {Tint(0), Tint(1)} {Tflt(0)}
	RET {Tflt(0)} {L1}
L1 (exit)
return (-3^0 + 5) // 3.0
function()
  return
    --[binary expr start] any
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[unary expr start] any
        -
         --[binary expr start] any
          3
         ^
          0
         --[binary expr end]
        --[unary expr end]
       +
        5
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    //
     3.0000000000000000
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[suffixed expr start] number
      --[primary start] number
       --[binary expr start] number
        --[unary expr start] number
        -
         --[binary expr start] number
          3
         ^
          0
         --[binary expr end]
        --[unary expr end]
       +
        5
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    //
     3.0000000000000000
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	POW {3 Kint(0), 0 Kint(1)} {Tflt(0)}
	UNMf {Tflt(0)} {Tflt(1)}
	ADDfi {Tflt(1), 5 Kint(2)} {Tflt(2)}
	IDIV {Tflt(2), 3 Kint(0)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return 0xF0.0 | 0xCC.0 ~ 0xAA & 0xFD
function()
  return
    --[binary expr start] any
     240.0000000000000000
    |
     --[binary expr start] any
      204.0000000000000000
     ~
      --[binary expr start] any
       170
      &
       253
      --[binary expr end]
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] integer
     240.0000000000000000
    |
     --[binary expr start] integer
      204.0000000000000000
     ~
      --[binary expr start] integer
       170
      &
       253
      --[binary expr end]
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	BANDii {170 Kint(2), 253 Kint(3)} {Tint(0)}
	BXOR {204.000000000000 Kflt(1), Tint(0)} {Tint(1)}
	BOR {240.000000000000 Kflt(0), Tint(1)} {Tint(0)}
	RET {Tint(0)} {L1}
L1 (exit)
return ~(~0xFF0 | 0xFF0)
function()
  return
    --[unary expr start] any
    ~
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[unary expr start] any
        ~
         4080
        --[unary expr end]
       |
        4080
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] any
    ~
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[unary expr start] any
        ~
         4080
        --[unary expr end]
       |
        4080
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	BNOT {4080 Kint(0)} {T(0)}
	BOR {T(0), 4080 Kint(0)} {T(1)}
	BNOT {T(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return ~~-100024.0
function()
  return
    --[unary expr start] any
    ~
     --[unary expr start] any
     ~
      --[unary expr start] any
      -
       100024.0000000000000000
      --[unary expr end]
     --[unary expr end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] any
    ~
     --[unary expr start] any
     ~
      --[unary expr start] number
      -
       100024.0000000000000000
      --[unary expr end]
     --[unary expr end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	UNMf {100024.000000000000 Kflt(0)} {Tflt(0)}
	BNOT {Tflt(0)} {T(0)}
	BNOT {T(0)} {T(1)}
	RET {T(1)} {L1}
L1 (exit)
return ((100 << 6) << -4) >> 2
function()
  return
    --[binary expr start] any
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           100
          <<
           6
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       <<
        --[unary expr start] any
        -
         4
        --[unary expr end]
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    >>
     2
    --[binary expr end]
end
function()
  return
    --[binary expr start] integer
     --[suffixed expr start] integer
      --[primary start] integer
       --[binary expr start] integer
        --[suffixed expr start] integer
         --[primary start] integer
          --[binary expr start] integer
           100
          <<
           6
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       <<
        --[unary expr start] integer
        -
         4
        --[unary expr end]
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    >>
     2
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	SHLii {100 Kint(0), 6 Kint(1)} {Tint(0)}
	UNMi {4 Kint(2)} {Tint(1)}
	SHLii {Tint(0), Tint(1)} {Tint(2)}
	SHRii {Tint(2), 2 Kint(3)} {Tint(1)}
	RET {Tint(1)} {L1}
L1 (exit)
return 2^3^2 == 2^(3^2)
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      2
     ^
      --[binary expr start] any
       3
      ^
       2
      --[binary expr end]
     --[binary expr end]
    ==
     --[binary expr start] any
      2
     ^
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         3
        ^
         2
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] boolean
     --[binary expr start] number
      2
     ^
      --[binary expr start] number
       3
      ^
       2
      --[binary expr end]
     --[binary expr end]
    ==
     --[binary expr start] number
      2
     ^
      --[suffixed expr start] number
       --[primary start] number
        --[binary expr start] number
         3
        ^
         2
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	POW {3 Kint(1), 2 Kint(0)} {Tflt(0)}
	POW {2 Kint(0), Tflt(0)} {Tflt(1)}
	POW {3 Kint(1), 2 Kint(0)} {Tflt(0)}
	POW {2 Kint(0), Tflt(0)} {Tflt(2)}
	EQff {Tflt(1), Tflt(2)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return 2^3*4 == (2^3)*4
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       2
      ^
       3
      --[binary expr end]
     *
      4
     --[binary expr end]
    ==
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         2
        ^
         3
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     *
      4
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] boolean
     --[binary expr start] number
      --[binary expr start] number
       2
      ^
       3
      --[binary expr end]
     *
      4
     --[binary expr end]
    ==
     --[binary expr start] number
      --[suffixed expr start] number
       --[primary start] number
        --[binary expr start] number
         2
        ^
         3
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     *
      4
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	POW {2 Kint(0), 3 Kint(1)} {Tflt(0)}
	MULfi {Tflt(0), 4 Kint(2)} {Tflt(1)}
	POW {2 Kint(0), 3 Kint(1)} {Tflt(0)}
	MULfi {Tflt(0), 4 Kint(2)} {Tflt(2)}
	EQff {Tflt(1), Tflt(2)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return 2.0^-2 == 1/4 and -2^- -2 == - - -4
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       2.0000000000000000
      ^
       --[unary expr start] any
       -
        2
       --[unary expr end]
      --[binary expr end]
     ==
      --[binary expr start] any
       1
      /
       4
      --[binary expr end]
     --[binary expr end]
    and
     --[binary expr start] any
      --[unary expr start] any
      -
       --[binary expr start] any
        2
       ^
        --[unary expr start] any
        -
         --[unary expr start] any
         -
          2
         --[unary expr end]
        --[unary expr end]
       --[binary expr end]
      --[unary expr end]
     ==
      --[unary expr start] any
      -
       --[unary expr start] any
       -
        --[unary expr start] any
        -
         4
        --[unary expr end]
       --[unary expr end]
      --[unary expr end]
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] boolean
      --[binary expr start] number
       2.0000000000000000
      ^
       --[unary expr start] integer
       -
        2
       --[unary expr end]
      --[binary expr end]
     ==
      --[binary expr start] number
       1
      /
       4
      --[binary expr end]
     --[binary expr end]
    and
     --[binary expr start] boolean
      --[unary expr start] number
      -
       --[binary expr start] number
        2
       ^
        --[unary expr start] integer
        -
         --[unary expr start] integer
         -
          2
         --[unary expr end]
        --[unary expr end]
       --[binary expr end]
      --[unary expr end]
     ==
      --[unary expr start] integer
      -
       --[unary expr start] integer
       -
        --[unary expr start] integer
        -
         4
        --[unary expr end]
       --[unary expr end]
      --[unary expr end]
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	UNMi {2.000000000000 Kflt(0)} {Tint(0)}
	POW {2.000000000000 Kflt(0), Tint(0)} {Tflt(0)}
	DIVii {1 Kint(1), 4 Kint(2)} {Tflt(1)}
	EQff {Tflt(0), Tflt(1)} {T(1)}
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L2, L3}
L1 (exit)
L2
	UNMi {2.000000000000 Kflt(0)} {Tint(0)}
	UNMi {Tint(0)} {Tint(1)}
	POW {2.000000000000 Kflt(0), Tint(1)} {Tflt(1)}
	UNMf {Tflt(1)} {Tflt(0)}
	UNMi {4 Kint(2)} {Tint(1)}
	UNMi {Tint(1)} {Tint(2)}
	UNMi {Tint(2)} {Tint(3)}
	EQ {Tflt(0), Tint(3)} {T(1)}
	MOV {T(1)} {T(0)}
	BR {L3}
L3
	RET {T(0)} {L1}
return not nil and 2 and not(2>3 or 3<2)
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[unary expr start] any
      not
       nil
      --[unary expr end]
     and
      2
     --[binary expr end]
    and
     --[unary expr start] any
     not
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[binary expr start] any
          2
         >
          3
         --[binary expr end]
        or
         --[binary expr start] any
          3
         <
          2
         --[binary expr end]
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     --[unary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[unary expr start] any
      not
       nil
      --[unary expr end]
     and
      2
     --[binary expr end]
    and
     --[unary expr start] any
     not
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[binary expr start] boolean
          2
         >
          3
         --[binary expr end]
        or
         --[binary expr start] boolean
          3
         <
          2
         --[binary expr end]
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     --[unary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	NOT {nil} {T(2)}
	MOV {T(2)} {T(1)}
	CBR {T(1)} {L4, L5}
L1 (exit)
L2
	LIii {3 Kint(1), 2 Kint(0)} {T(2)}
	MOV {T(2)} {T(1)}
	CBR {T(1)} {L7, L6}
L3
	RET {T(0)} {L1}
L4
	MOV {2 Kint(0)} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L2, L3}
L6
	LIii {3 Kint(1), 2 Kint(0)} {T(2)}
	MOV {T(2)} {T(1)}
	BR {L7}
L7
	NOT {T(1)} {T(2)}
	MOV {T(2)} {T(0)}
	BR {L3}
return -3-1-5 == 0+0-9
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] any
       -
        3
       --[unary expr end]
      -
       1
      --[binary expr end]
     -
      5
     --[binary expr end]
    ==
     --[binary expr start] any
      --[binary expr start] any
       0
      +
       0
      --[binary expr end]
     -
      9
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] boolean
     --[binary expr start] integer
      --[binary expr start] integer
       --[unary expr start] integer
       -
        3
       --[unary expr end]
      -
       1
      --[binary expr end]
     -
      5
     --[binary expr end]
    ==
     --[binary expr start] integer
      --[binary expr start] integer
       0
      +
       0
      --[binary expr end]
     -
      9
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	UNMi {3 Kint(0)} {Tint(0)}
	SUBii {Tint(0), 1 Kint(1)} {Tint(1)}
	SUBii {Tint(1), 5 Kint(2)} {Tint(0)}
	ADDii {0 Kint(3), 0 Kint(3)} {Tint(1)}
	SUBii {Tint(1), 9 Kint(4)} {Tint(2)}
	EQii {Tint(0), Tint(2)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return -2^2 == -4 and (-2)^2 == 4 and 2*2-3-1 == 0
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] any
       -
        --[binary expr start] any
         2
        ^
         2
        --[binary expr end]
       --[unary expr end]
      ==
       --[unary expr start] any
       -
        4
       --[unary expr end]
      --[binary expr end]
     and
      --[binary expr start] any
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
          --[unary expr start] any
          -
           2
          --[unary expr end]
         --[primary end]
        --[suffixed expr end]
       ^
        2
       --[binary expr end]
      ==
       4
      --[binary expr end]
     --[binary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       --[binary expr start] any
        --[binary expr start] any
         2
        *
         2
        --[binary expr end]
       -
        3
       --[binary expr end]
      -
       1
      --[binary expr end]
     ==
      0
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] boolean
       --[unary expr start] number
       -
        --[binary expr start] number
         2
        ^
         2
        --[binary expr end]
       --[unary expr end]
      ==
       --[unary expr start] integer
       -
        4
       --[unary expr end]
      --[binary expr end]
     and
      --[binary expr start] boolean
       --[binary expr start] number
        --[suffixed expr start] integer
         --[primary start] integer
          --[unary expr start] integer
          -
           2
          --[unary expr end]
         --[primary end]
        --[suffixed expr end]
       ^
        2
       --[binary expr end]
      ==
       4
      --[binary expr end]
     --[binary expr end]
    and
     --[binary expr start] boolean
      --[binary expr start] integer
       --[binary expr start] integer
        --[binary expr start] integer
         2
        *
         2
        --[binary expr end]
       -
        3
       --[binary expr end]
      -
       1
      --[binary expr end]
     ==
      0
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	POW {2 Kint(0), 2 Kint(0)} {Tflt(0)}
	UNMf {Tflt(0)} {Tflt(1)}
	UNMi {4 Kint(1)} {Tint(0)}
	EQ {Tflt(1), Tint(0)} {T(2)}
	MOV {T(2)} {T(1)}
	CBR {T(1)} {L4, L5}
L1 (exit)
L2
	MULii {2 Kint(0), 2 Kint(0)} {Tint(0)}
	SUBii {Tint(0), 3 Kint(2)} {Tint(1)}
	SUBii {Tint(1), 1 Kint(3)} {Tint(0)}
	EQii {Tint(0), 0 Kint(4)} {T(1)}
	MOV {T(1)} {T(0)}
	BR {L3}
L3
	RET {T(0)} {L1}
L4
	UNMi {2 Kint(0)} {Tint(0)}
	POW {Tint(0), 2 Kint(0)} {Tflt(1)}
	EQ {Tflt(1), 4 Kint(1)} {T(2)}
	MOV {T(2)} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L2, L3}

function()
end
function()
end
define Proc(0)
L0 (entry)
	BR {L1}
L1 (exit)
return 2*1+3/3 == 3 and 1+2 .. 3*1 == '33'
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[binary expr start] any
        2
       *
        1
       --[binary expr end]
      +
       --[binary expr start] any
        3
       /
        3
       --[binary expr end]
      --[binary expr end]
     ==
      3
     --[binary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       --[binary expr start] any
        1
       +
        2
       --[binary expr end]
      ..
       --[binary expr start] any
        3
       *
        1
       --[binary expr end]
      --[binary expr end]
     ==
      '33'
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] boolean
      --[binary expr start] number
       --[binary expr start] integer
        2
       *
        1
       --[binary expr end]
      +
       --[binary expr start] number
        3
       /
        3
       --[binary expr end]
      --[binary expr end]
     ==
      3
     --[binary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       --[binary expr start] integer
        1
       +
        2
       --[binary expr end]
      ..
       --[binary expr start] integer
        3
       *
        1
       --[binary expr end]
      --[binary expr end]
     ==
      '33'
     --[binary expr end]
    --[binary expr end]
end
return not(2+1 > 3*1) and 'a'..'b' > 'a'
function()
  return
    --[binary expr start] any
     --[unary expr start] any
     not
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[binary expr start] any
          2
         +
          1
         --[binary expr end]
        >
         --[binary expr start] any
          3
         *
          1
         --[binary expr end]
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     --[unary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       'a'
      ..
       'b'
      --[binary expr end]
     >
      'a'
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[unary expr start] any
     not
      --[suffixed expr start] boolean
       --[primary start] boolean
        --[binary expr start] boolean
         --[binary expr start] integer
          2
         +
          1
         --[binary expr end]
        >
         --[binary expr start] integer
          3
         *
          1
         --[binary expr end]
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     --[unary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       'a'
      ..
       'b'
      --[binary expr end]
     >
      'a'
     --[binary expr end]
    --[binary expr end]
end
return '7' .. 3 << 1 == 146
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       '7'
      ..
       3
      --[binary expr end]
     <<
      1
     --[binary expr end]
    ==
     146
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       '7'
      ..
       3
      --[binary expr end]
     <<
      1
     --[binary expr end]
    ==
     146
    --[binary expr end]
end
return 10 >> 1 .. '9' == 0
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      10
     >>
      --[binary expr start] any
       1
      ..
       '9'
      --[binary expr end]
     --[binary expr end]
    ==
     0
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      10
     >>
      --[binary expr start] any
       1
      ..
       '9'
      --[binary expr end]
     --[binary expr end]
    ==
     0
    --[binary expr end]
end
return 10 | 1 .. '9' == 27
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      10
     |
      --[binary expr start] any
       1
      ..
       '9'
      --[binary expr end]
     --[binary expr end]
    ==
     27
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      10
     |
      --[binary expr start] any
       1
      ..
       '9'
      --[binary expr end]
     --[binary expr end]
    ==
     27
    --[binary expr end]
end
return 0xF0 | 0xCC ~ 0xAA & 0xFD == 0xF4
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      240
     |
      --[binary expr start] any
       204
      ~
       --[binary expr start] any
        170
       &
        253
       --[binary expr end]
      --[binary expr end]
     --[binary expr end]
    ==
     244
    --[binary expr end]
end
function()
  return
    --[binary expr start] boolean
     --[binary expr start] integer
      240
     |
      --[binary expr start] integer
       204
      ~
       --[binary expr start] integer
        170
       &
        253
       --[binary expr end]
      --[binary expr end]
     --[binary expr end]
    ==
     244
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	BANDii {170 Kint(2), 253 Kint(3)} {Tint(0)}
	BXORii {204 Kint(1), Tint(0)} {Tint(1)}
	BORii {240 Kint(0), Tint(1)} {Tint(0)}
	EQii {Tint(0), 244 Kint(4)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return 0xFD & 0xAA ~ 0xCC | 0xF0 == 0xF4
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[binary expr start] any
        253
       &
        170
       --[binary expr end]
      ~
       204
      --[binary expr end]
     |
      240
     --[binary expr end]
    ==
     244
    --[binary expr end]
end
function()
  return
    --[binary expr start] boolean
     --[binary expr start] integer
      --[binary expr start] integer
       --[binary expr start] integer
        253
       &
        170
       --[binary expr end]
      ~
       204
      --[binary expr end]
     |
      240
     --[binary expr end]
    ==
     244
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	BANDii {253 Kint(0), 170 Kint(1)} {Tint(0)}
	BXORii {Tint(0), 204 Kint(2)} {Tint(1)}
	BORii {Tint(1), 240 Kint(3)} {Tint(0)}
	EQii {Tint(0), 244 Kint(4)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return 0xF0 & 0x0F + 1 == 0x10
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      240
     &
      --[binary expr start] any
       15
      +
       1
      --[binary expr end]
     --[binary expr end]
    ==
     16
    --[binary expr end]
end
function()
  return
    --[binary expr start] boolean
     --[binary expr start] integer
      240
     &
      --[binary expr start] integer
       15
      +
       1
      --[binary expr end]
     --[binary expr end]
    ==
     16
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	ADDii {15 Kint(1), 1 Kint(2)} {Tint(0)}
	BANDii {240 Kint(0), Tint(0)} {Tint(1)}
	EQii {Tint(1), 16 Kint(3)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return 3^4//2^3//5 == 2
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[binary expr start] any
        3
       ^
        4
       --[binary expr end]
      //
       --[binary expr start] any
        2
       ^
        3
       --[binary expr end]
      --[binary expr end]
     //
      5
     --[binary expr end]
    ==
     2
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[binary expr start] number
        3
       ^
        4
       --[binary expr end]
      //
       --[binary expr start] number
        2
       ^
        3
       --[binary expr end]
      --[binary expr end]
     //
      5
     --[binary expr end]
    ==
     2
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	POW {3 Kint(0), 4 Kint(1)} {Tflt(0)}
	POW {2 Kint(2), 3 Kint(0)} {Tflt(1)}
	IDIV {Tflt(0), Tflt(1)} {T(0)}
	IDIV {T(0), 5 Kint(3)} {T(1)}
	EQ {T(1), 2 Kint(2)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return not ((true or false) and nil)
function()
  return
    --[unary expr start] any
    not
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           true
          or
           false
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       and
        nil
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] any
    not
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           true
          or
           false
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       and
        nil
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	MOV {true} {T(1)}
	CBR {T(1)} {L5, L4}
L1 (exit)
L2
	MOV {nil} {T(0)}
	BR {L3}
L3
	NOT {T(0)} {T(1)}
	RET {T(1)} {L1}
L4
	MOV {false} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L2, L3}
return true or false and nil
function()
  return
    --[binary expr start] any
     true
    or
     --[binary expr start] any
      false
     and
      nil
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     true
    or
     --[binary expr start] any
      false
     and
      nil
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	MOV {true} {T(0)}
	CBR {T(0)} {L3, L2}
L1 (exit)
L2
	MOV {false} {T(1)}
	CBR {T(1)} {L4, L5}
L3
	RET {T(0)} {L1}
L4
	MOV {nil} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	BR {L3}
return (((1 or false) and true) or false) == true
function()
  return
    --[binary expr start] any
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           --[suffixed expr start] any
            --[primary start] any
             --[binary expr start] any
              1
             or
              false
             --[binary expr end]
            --[primary end]
           --[suffixed expr end]
          and
           true
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       or
        false
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    ==
     true
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           --[suffixed expr start] any
            --[primary start] any
             --[binary expr start] any
              1
             or
              false
             --[binary expr end]
            --[primary end]
           --[suffixed expr end]
          and
           true
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       or
        false
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    ==
     true
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	MOV {1 Kint(0)} {T(2)}
	CBR {T(2)} {L7, L6}
L1 (exit)
L2
	MOV {false} {T(0)}
	BR {L3}
L3
	EQ {T(0), true} {T(1)}
	RET {T(1)} {L1}
L4
	MOV {true} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L3, L2}
L6
	MOV {false} {T(2)}
	BR {L7}
L7
	MOV {T(2)} {T(1)}
	CBR {T(1)} {L4, L5}
return (((nil and true) or false) and true) == false
function()
  return
    --[binary expr start] any
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           --[suffixed expr start] any
            --[primary start] any
             --[binary expr start] any
              nil
             and
              true
             --[binary expr end]
            --[primary end]
           --[suffixed expr end]
          or
           false
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       and
        true
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    ==
     false
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[suffixed expr start] any
      --[primary start] any
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           --[suffixed expr start] any
            --[primary start] any
             --[binary expr start] any
              nil
             and
              true
             --[binary expr end]
            --[primary end]
           --[suffixed expr end]
          or
           false
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       and
        true
       --[binary expr end]
      --[primary end]
     --[suffixed expr end]
    ==
     false
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	MOV {nil} {T(2)}
	CBR {T(2)} {L6, L7}
L1 (exit)
L2
	MOV {true} {T(0)}
	BR {L3}
L3
	EQ {T(0), false} {T(1)}
	RET {T(1)} {L1}
L4
	MOV {false} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L2, L3}
L6
	MOV {true} {T(2)}
	BR {L7}
L7
	MOV {T(2)} {T(1)}
	CBR {T(1)} {L5, L4}
return -(1 or 2) == -1 and (1 and 2)+(-1.25 or -4) == 0.75
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[unary expr start] any
      -
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          1
         or
          2
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      --[unary expr end]
     ==
      --[unary expr start] any
      -
       1
      --[unary expr end]
     --[binary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          1
         and
          2
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      +
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          --[unary expr start] any
          -
           1.2500000000000000
          --[unary expr end]
         or
          --[unary expr start] any
          -
           4
          --[unary expr end]
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      --[binary expr end]
     ==
      0.7500000000000000
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[unary expr start] any
      -
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          1
         or
          2
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      --[unary expr end]
     ==
      --[unary expr start] integer
      -
       1
      --[unary expr end]
     --[binary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          1
         and
          2
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      +
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          --[unary expr start] number
          -
           1.2500000000000000
          --[unary expr end]
         or
          --[unary expr start] integer
          -
           4
          --[unary expr end]
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      --[binary expr end]
     ==
      0.7500000000000000
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	MOV {1 Kint(0)} {T(1)}
	CBR {T(1)} {L5, L4}
L1 (exit)
L2
	MOV {1 Kint(0)} {T(3)}
	CBR {T(3)} {L6, L7}
L3
	RET {T(0)} {L1}
L4
	MOV {2 Kint(1)} {T(1)}
	BR {L5}
L5
	UNM {T(1)} {T(2)}
	UNMi {1 Kint(0)} {Tint(0)}
	EQ {T(2), Tint(0)} {T(3)}
	MOV {T(3)} {T(0)}
	CBR {T(0)} {L2, L3}
L6
	MOV {2 Kint(1)} {T(3)}
	BR {L7}
L7
	UNMf {1 Kint(0)} {Tflt(0)}
	MOV {Tflt(0)} {T(2)}
	CBR {T(2)} {L9, L8}
L8
	UNMi {4 Kint(2)} {Tint(0)}
	MOV {Tint(0)} {T(2)}
	BR {L9}
L9
	ADD {T(3), T(2)} {T(4)}
	EQ {T(4), 0.750000000000 Kflt(3)} {T(2)}
	MOV {T(2)} {T(0)}
	BR {L3}
return (b or a)+1 == 2 and (10 or a)+1 == 11
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          --[suffixed expr start] any
           --[primary start] any
             b --global symbol any 
           --[primary end]
          --[suffixed expr end]
         or
          --[suffixed expr start] any
           --[primary start] any
             a --global symbol any 
           --[primary end]
          --[suffixed expr end]
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      +
       1
      --[binary expr end]
     ==
      2
     --[binary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          10
         or
          --[suffixed expr start] any
           --[primary start] any
             a --global symbol any 
           --[primary end]
          --[suffixed expr end]
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      +
       1
      --[binary expr end]
     ==
      11
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          --[suffixed expr start] any
           --[primary start] any
             b --global symbol any 
           --[primary end]
          --[suffixed expr end]
         or
          --[suffixed expr start] any
           --[primary start] any
             a --global symbol any 
           --[primary end]
          --[suffixed expr end]
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      +
       1
      --[binary expr end]
     ==
      2
     --[binary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          10
         or
          --[suffixed expr start] any
           --[primary start] any
             a --global symbol any 
           --[primary end]
          --[suffixed expr end]
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      +
       1
      --[binary expr end]
     ==
      11
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {b} {T(2)}
	MOV {T(2)} {T(1)}
	CBR {T(1)} {L5, L4}
L1 (exit)
L2
	MOV {10 Kint(2)} {T(1)}
	CBR {T(1)} {L7, L6}
L3
	RET {T(0)} {L1}
L4
	LOADGLOBAL {a} {T(2)}
	MOV {T(2)} {T(1)}
	BR {L5}
L5
	ADD {T(1), 1 Kint(0)} {T(2)}
	EQ {T(2), 2 Kint(1)} {T(1)}
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L2, L3}
L6
	LOADGLOBAL {a} {T(2)}
	MOV {T(2)} {T(1)}
	BR {L7}
L7
	ADD {T(1), 1 Kint(0)} {T(2)}
	EQ {T(2), 11 Kint(3)} {T(1)}
	MOV {T(1)} {T(0)}
	BR {L3}
return ((2<3) or 1) == true and (2<3 and 4) == 4
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[suffixed expr start] any
          --[primary start] any
           --[binary expr start] any
            2
           <
            3
           --[binary expr end]
          --[primary end]
         --[suffixed expr end]
        or
         1
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     ==
      true
     --[binary expr end]
    and
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[binary expr start] any
          2
         <
          3
         --[binary expr end]
        and
         4
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     ==
      4
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[suffixed expr start] boolean
          --[primary start] boolean
           --[binary expr start] boolean
            2
           <
            3
           --[binary expr end]
          --[primary end]
         --[suffixed expr end]
        or
         1
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     ==
      true
     --[binary expr end]
    and
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[binary expr start] boolean
          2
         <
          3
         --[binary expr end]
        and
         4
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     ==
      4
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	LIii {2 Kint(0), 3 Kint(1)} {T(2)}
	MOV {T(2)} {T(1)}
	CBR {T(1)} {L5, L4}
L1 (exit)
L2
	LIii {2 Kint(0), 3 Kint(1)} {T(1)}
	MOV {T(1)} {T(2)}
	CBR {T(2)} {L6, L7}
L3
	RET {T(0)} {L1}
L4
	MOV {1 Kint(2)} {T(1)}
	BR {L5}
L5
	EQ {T(1), true} {T(2)}
	MOV {T(2)} {T(0)}
	CBR {T(0)} {L2, L3}
L6
	MOV {4 Kint(3)} {T(2)}
	BR {L7}
L7
	EQ {T(2), 4 Kint(3)} {T(1)}
	MOV {T(1)} {T(0)}
	BR {L3}
return (x>y) and x or y == 2
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[suffixed expr start] any
          --[primary start] any
            x --global symbol any 
          --[primary end]
         --[suffixed expr end]
        >
         --[suffixed expr start] any
          --[primary start] any
            y --global symbol any 
          --[primary end]
         --[suffixed expr end]
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     and
      --[suffixed expr start] any
       --[primary start] any
         x --global symbol any 
       --[primary end]
      --[suffixed expr end]
     --[binary expr end]
    or
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
         y --global symbol any 
       --[primary end]
      --[suffixed expr end]
     ==
      2
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[suffixed expr start] any
          --[primary start] any
            x --global symbol any 
          --[primary end]
         --[suffixed expr end]
        >
         --[suffixed expr start] any
          --[primary start] any
            y --global symbol any 
          --[primary end]
         --[suffixed expr end]
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     and
      --[suffixed expr start] any
       --[primary start] any
         x --global symbol any 
       --[primary end]
      --[suffixed expr end]
     --[binary expr end]
    or
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
         y --global symbol any 
       --[primary end]
      --[suffixed expr end]
     ==
      2
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(2)}
	LOADGLOBAL {y} {T(3)}
	LT {T(3), T(2)} {T(4)}
	MOV {T(4)} {T(1)}
	CBR {T(1)} {L4, L5}
L1 (exit)
L2
	LOADGLOBAL {y} {T(1)}
	EQ {T(1), 2 Kint(0)} {T(4)}
	MOV {T(4)} {T(0)}
	BR {L3}
L3
	RET {T(0)} {L1}
L4
	LOADGLOBAL {x} {T(4)}
	MOV {T(4)} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L3, L2}
function x() for i = 1, 10 do; print(i); end end
function()
   x --global symbol any 
   =
    function()
    --locals  i
      for
        i --local symbol any 
      =
        1
       ,
        10
      do
         --[expression statement start]
          --[expression list start]
            --[suffixed expr start] any
             --[primary start] any
               print --global symbol any 
             --[primary end]
             --[suffix list start]
               --[function call start] any
                (
                  --[suffixed expr start] any
                   --[primary start] any
                     i --local symbol any 
                   --[primary end]
                  --[suffixed expr end]
                )
               --[function call end]
             --[suffix list end]
            --[suffixed expr end]
          --[expression list end]
         --[expression statement end]
      end
    end
end
function()
   x --global symbol any 
   =
    function()
    --locals  i
      for
        i --local symbol integer 
      =
        1
       ,
        10
      do
         --[expression statement start]
          --[expression list start]
            --[suffixed expr start] any
             --[primary start] any
               print --global symbol any 
             --[primary end]
             --[suffix list start]
               --[function call start] any
                (
                  --[suffixed expr start] integer
                   --[primary start] integer
                     i --local symbol integer 
                   --[primary end]
                  --[suffixed expr end]
                )
               --[function call end]
             --[suffix list end]
            --[suffixed expr end]
          --[expression list end]
         --[expression statement end]
      end
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(1)}
	STOREGLOBAL {x, T(1)}
	BR {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	MOV {1 Kint(0)} {Tint(0)}
	MOV {10 Kint(1)} {Tint(1)}
	MOV {1 Kint(0)} {Tint(2)}
	LIii {0 Kint(2), Tint(2)} {Tint(3)}
	SUBii {Tint(0), Tint(2)} {Tint(0)}
	BR {L2}
L1 (exit)
L2
	ADDii {Tint(0), Tint(2)} {Tint(0)}
	CBR {Tint(3)} {L3, L4}
L3
	LEii {Tint(1), Tint(0)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L4
	LIii {Tint(0), Tint(1)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L5
	MOV {Tint(0)} {local(i, 0)}
	LOADGLOBAL {print} {T(0)}
	CALL {T(0), local(i, 0)} {T(0..)}
	BR {L2}
L6
	BR {L1}
function x() local a=1; function y() return function() return a end end; end
function()
   x --global symbol any 
   =
    function()
    --locals  a
      local
      --[symbols]
        a --local symbol any 
      --[expressions]
        1
       y --global symbol any 
       =
        function()
        --upvalues  a
          return
            function()
            --upvalues  a
              return
                --[suffixed expr start] any
                 --[primary start] any
                   a --upvalue any 
                 --[primary end]
                --[suffixed expr end]
            end
        end
    end
end
function()
   x --global symbol any 
   =
    function()
    --locals  a
      local
      --[symbols]
        a --local symbol any 
      --[expressions]
        1
       y --global symbol any 
       =
        function()
        --upvalues  a
          return
            function()
            --upvalues  a
              return
                --[suffixed expr start] any
                 --[primary start] any
                   a --upvalue any 
                 --[primary end]
                --[suffixed expr end]
            end
        end
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(1)}
	STOREGLOBAL {x, T(1)}
	BR {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	MOV {1 Kint(0)} {local(a, 0)}
	CLOSURE {Proc(2)} {T(1)}
	STOREGLOBAL {y, T(1)}
	BR {L1}
L1 (exit)
define Proc(2)
L0 (entry)
	CLOSURE {Proc(3)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(3)
L0 (entry)
	RET {Upval(0)} {L1}
L1 (exit)
return @integer 1
function()
  return
    --[unary expr start] any
    @integer
     1
    --[unary expr end]
end
function()
  return
    --[unary expr start] integer
    @integer
     1
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	RET {1 Kint(0)} {L1}
L1 (exit)
return @string 'hello'
function()
  return
    --[unary expr start] any
    @string
     'hello'
    --[unary expr end]
end
function()
  return
    --[unary expr start] string
    @string
     'hello'
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	RET {'hello' Ks(0)} {L1}
L1 (exit)
return @table {}
function()
  return
    --[unary expr start] any
    @table
     { --[table constructor start] table
     } --[table constructor end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] table
    @table
     { --[table constructor start] table
     } --[table constructor end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	NEWTABLE {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return @integer[] {}
function()
  return
    --[unary expr start] any
    @integer[]
     { --[table constructor start] table
     } --[table constructor end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] integer[]
    @integer[]
     { --[table constructor start] integer[]
     } --[table constructor end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	NEWIARRAY {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return @number[] {}
function()
  return
    --[unary expr start] any
    @number[]
     { --[table constructor start] table
     } --[table constructor end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] number[]
    @number[]
     { --[table constructor start] number[]
     } --[table constructor end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	NEWFARRAY {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return @closure function() end
function()
  return
    --[unary expr start] any
    @closure
     function()
     end
    --[unary expr end]
end
function()
  return
    --[unary expr start] closure
    @closure
     function()
     end
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	BR {L1}
L1 (exit)
return @number 54.4
function()
  return
    --[unary expr start] any
    @number
     54.3999999999999986
    --[unary expr end]
end
function()
  return
    --[unary expr start] number
    @number
     54.3999999999999986
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	RET {54.400000000000 Kflt(0)} {L1}
L1 (exit)
return @User.Type a
function()
  return
    --[unary expr start] any
    @<usertype>
     --[suffixed expr start] any
      --[primary start] any
        a --global symbol any 
      --[primary end]
     --[suffixed expr end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] User.Type
    @<usertype>
     --[suffixed expr start] any
      --[primary start] any
        a --global symbol any 
      --[primary end]
     --[suffixed expr end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {a} {T(0)}
	TOTYPE {'User.Type' Ks(0)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return {1,2,3}
function()
  return
    { --[table constructor start] table
      --[indexed assign start] integer
      --[value start]
       1
      --[value end]
      --[indexed assign end]
     ,
      --[indexed assign start] integer
      --[value start]
       2
      --[value end]
      --[indexed assign end]
     ,
      --[indexed assign start] integer
      --[value start]
       3
      --[value end]
      --[indexed assign end]
    } --[table constructor end]
end
function()
  return
    { --[table constructor start] table
      --[indexed assign start] integer
      --[value start]
       1
      --[value end]
      --[indexed assign end]
     ,
      --[indexed assign start] integer
      --[value start]
       2
      --[value end]
      --[indexed assign end]
     ,
      --[indexed assign start] integer
      --[value start]
       3
      --[value end]
      --[indexed assign end]
    } --[table constructor end]
end
define Proc(0)
L0 (entry)
	NEWTABLE {T(0)}
	TPUTik {T(0), 1 Kint(0), 1 Kint(0)}
	TPUTik {T(0), 2 Kint(1), 2 Kint(1)}
	TPUTik {T(0), 3 Kint(2), 3 Kint(2)}
	RET {T(0)} {L1}
L1 (exit)
return {[1] = a}
function()
  return
    { --[table constructor start] table
      --[indexed assign start] any
      --[index start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
      --[index end]
      --[value start]
       --[suffixed expr start] any
        --[primary start] any
          a --global symbol any 
        --[primary end]
       --[suffixed expr end]
      --[value end]
      --[indexed assign end]
    } --[table constructor end]
end
function()
  return
    { --[table constructor start] table
      --[indexed assign start] any
      --[index start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
      --[index end]
      --[value start]
       --[suffixed expr start] any
        --[primary start] any
          a --global symbol any 
        --[primary end]
       --[suffixed expr end]
      --[value end]
      --[indexed assign end]
    } --[table constructor end]
end
define Proc(0)
L0 (entry)
	NEWTABLE {T(0)}
	LOADGLOBAL {a} {T(1)}
	TPUTik {T(0), 1 Kint(0), T(1)}
	RET {T(0)} {L1}
L1 (exit)
return {a = b}
function()
  return
    { --[table constructor start] table
      --[indexed assign start] any
      --[index start]
       --[field selector start] any
        .
         'a'
       --[field selector end]
      --[index end]
      --[value start]
       --[suffixed expr start] any
        --[primary start] any
          b --global symbol any 
        --[primary end]
       --[suffixed expr end]
      --[value end]
      --[indexed assign end]
    } --[table constructor end]
end
function()
  return
    { --[table constructor start] table
      --[indexed assign start] any
      --[index start]
       --[field selector start] any
        .
         'a'
       --[field selector end]
      --[index end]
      --[value start]
       --[suffixed expr start] any
        --[primary start] any
          b --global symbol any 
        --[primary end]
       --[suffixed expr end]
      --[value end]
      --[indexed assign end]
    } --[table constructor end]
end
define Proc(0)
L0 (entry)
	NEWTABLE {T(0)}
	LOADGLOBAL {b} {T(1)}
	TPUTsk {T(0), 'a' Ks(0), T(1)}
	RET {T(0)} {L1}
L1 (exit)
return @integer[]{[1] = 5.5, [2] = 4}
function()
  return
    --[unary expr start] any
    @integer[]
     { --[table constructor start] table
       --[indexed assign start] number
       --[index start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
       --[index end]
       --[value start]
        5.5000000000000000
       --[value end]
       --[indexed assign end]
      ,
       --[indexed assign start] integer
       --[index start]
        --[Y index start] any
         [
          2
         ]
        --[Y index end]
       --[index end]
       --[value start]
        4
       --[value end]
       --[indexed assign end]
     } --[table constructor end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] integer[]
    @integer[]
     { --[table constructor start] integer[]
       --[indexed assign start] number
       --[index start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
       --[index end]
       --[value start]
        5.5000000000000000
       --[value end]
       --[indexed assign end]
      ,
       --[indexed assign start] integer
       --[index start]
        --[Y index start] any
         [
          2
         ]
        --[Y index end]
       --[index end]
       --[value start]
        4
       --[value end]
       --[indexed assign end]
     } --[table constructor end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	NEWIARRAY {T(0)}
	IAPUT {T(0), 1 Kint(0), 5.500000000000 Kflt(1)}
	IAPUTiv {T(0), 2 Kint(2), 4 Kint(3)}
	RET {T(0)} {L1}
L1 (exit)
return @number[] {[1] = 4, [2] = 5.4}
function()
  return
    --[unary expr start] any
    @number[]
     { --[table constructor start] table
       --[indexed assign start] integer
       --[index start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
       --[index end]
       --[value start]
        4
       --[value end]
       --[indexed assign end]
      ,
       --[indexed assign start] number
       --[index start]
        --[Y index start] any
         [
          2
         ]
        --[Y index end]
       --[index end]
       --[value start]
        5.4000000000000004
       --[value end]
       --[indexed assign end]
     } --[table constructor end]
    --[unary expr end]
end
function()
  return
    --[unary expr start] number[]
    @number[]
     { --[table constructor start] number[]
       --[indexed assign start] integer
       --[index start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
       --[index end]
       --[value start]
        4
       --[value end]
       --[indexed assign end]
      ,
       --[indexed assign start] number
       --[index start]
        --[Y index start] any
         [
          2
         ]
        --[Y index end]
       --[index end]
       --[value start]
        5.4000000000000004
       --[value end]
       --[indexed assign end]
     } --[table constructor end]
    --[unary expr end]
end
define Proc(0)
L0 (entry)
	NEWFARRAY {T(0)}
	FAPUT {T(0), 1 Kint(0), 4 Kint(1)}
	FAPUTfv {T(0), 2 Kint(2), 5.400000000000 Kflt(3)}
	RET {T(0)} {L1}
L1 (exit)
if 1 == 1 then return true else return false end
function()
  if
   --[binary expr start] any
    1
   ==
    1
   --[binary expr end]
  then
    return
      true
  else
    return
      false
  end
end
function()
  if
   --[binary expr start] boolean
    1
   ==
    1
   --[binary expr end]
  then
    return
      true
  else
    return
      false
  end
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	EQii {1 Kint(0), 1 Kint(0)} {T(0)}
	CBR {T(0)} {L3, L4}
L3
	RET {true} {L1}
L4
	RET {false} {L1}
L5
	BR {L1}
if 1 ~= 1 then return 0 elseif 1 < 2 then return 1 elseif 1 < 2 then return 2 else return 5 end
function()
  if
   --[binary expr start] any
    1
   ~=
    1
   --[binary expr end]
  then
    return
      0
  elseif
   --[binary expr start] any
    1
   <
    2
   --[binary expr end]
  then
    return
      1
  elseif
   --[binary expr start] any
    1
   <
    2
   --[binary expr end]
  then
    return
      2
  else
    return
      5
  end
end
function()
  if
   --[binary expr start] boolean
    1
   ~=
    1
   --[binary expr end]
  then
    return
      0
  elseif
   --[binary expr start] boolean
    1
   <
    2
   --[binary expr end]
  then
    return
      1
  elseif
   --[binary expr start] boolean
    1
   <
    2
   --[binary expr end]
  then
    return
      2
  else
    return
      5
  end
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	EQii {1 Kint(0), 1 Kint(0)} {T(0)}
	CBR {T(0)} {L5, L3}
L3
	LIii {1 Kint(0), 2 Kint(1)} {T(1)}
	CBR {T(1)} {L6, L4}
L4
	LIii {1 Kint(0), 2 Kint(1)} {T(2)}
	CBR {T(2)} {L7, L8}
L5
	RET {0 Kint(2)} {L1}
L6
	RET {1 Kint(0)} {L1}
L7
	RET {2 Kint(1)} {L1}
L8
	RET {5 Kint(3)} {L1}
L9
	BR {L1}
if 1 == 1 then return 'hi' end
function()
  if
   --[binary expr start] any
    1
   ==
    1
   --[binary expr end]
  then
    return
      'hi'
  end
end
function()
  if
   --[binary expr start] boolean
    1
   ==
    1
   --[binary expr end]
  then
    return
      'hi'
  end
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	EQii {1 Kint(0), 1 Kint(0)} {T(0)}
	CBR {T(0)} {L3, L4}
L3
	RET {'hi' Ks(1)} {L1}
L4
	BR {L1}
if 5 + 5 == 10 then return 'got it' else if 6 < 7 then return 4 end end
function()
  if
   --[binary expr start] any
    --[binary expr start] any
     5
    +
     5
    --[binary expr end]
   ==
    10
   --[binary expr end]
  then
    return
      'got it'
  else
    if
     --[binary expr start] any
      6
     <
      7
     --[binary expr end]
    then
      return
        4
    end
  end
end
function()
  if
   --[binary expr start] boolean
    --[binary expr start] integer
     5
    +
     5
    --[binary expr end]
   ==
    10
   --[binary expr end]
  then
    return
      'got it'
  else
    if
     --[binary expr start] boolean
      6
     <
      7
     --[binary expr end]
    then
      return
        4
    end
  end
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	ADDii {5 Kint(0), 5 Kint(0)} {Tint(0)}
	EQii {Tint(0), 10 Kint(1)} {T(0)}
	CBR {T(0)} {L3, L4}
L3
	RET {'got it' Ks(2)} {L1}
L4
	BR {L6}
L5
	BR {L1}
L6
	LIii {6 Kint(3), 7 Kint(4)} {T(1)}
	CBR {T(1)} {L7, L8}
L7
	RET {4 Kint(5)} {L1}
L8
	BR {L5}
if 5 + 5 == 10 then return 'got it' elseif 6 < 7 then return 4 end
function()
  if
   --[binary expr start] any
    --[binary expr start] any
     5
    +
     5
    --[binary expr end]
   ==
    10
   --[binary expr end]
  then
    return
      'got it'
  elseif
   --[binary expr start] any
    6
   <
    7
   --[binary expr end]
  then
    return
      4
  end
end
function()
  if
   --[binary expr start] boolean
    --[binary expr start] integer
     5
    +
     5
    --[binary expr end]
   ==
    10
   --[binary expr end]
  then
    return
      'got it'
  elseif
   --[binary expr start] boolean
    6
   <
    7
   --[binary expr end]
  then
    return
      4
  end
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	ADDii {5 Kint(0), 5 Kint(0)} {Tint(0)}
	EQii {Tint(0), 10 Kint(1)} {T(0)}
	CBR {T(0)} {L4, L3}
L3
	LIii {6 Kint(2), 7 Kint(3)} {T(1)}
	CBR {T(1)} {L5, L6}
L4
	RET {'got it' Ks(4)} {L1}
L5
	RET {4 Kint(5)} {L1}
L6
	BR {L1}
return 1 and 2
function()
  return
    --[binary expr start] any
     1
    and
     2
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     1
    and
     2
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	MOV {1 Kint(0)} {T(0)}
	CBR {T(0)} {L2, L3}
L1 (exit)
L2
	MOV {2 Kint(1)} {T(0)}
	BR {L3}
L3
	RET {T(0)} {L1}
return 3 and 4 and 5
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      3
     and
      4
     --[binary expr end]
    and
     5
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      3
     and
      4
     --[binary expr end]
    and
     5
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	MOV {3 Kint(0)} {T(1)}
	CBR {T(1)} {L4, L5}
L1 (exit)
L2
	MOV {5 Kint(2)} {T(0)}
	BR {L3}
L3
	RET {T(0)} {L1}
L4
	MOV {4 Kint(1)} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L2, L3}
return 1 or 2
function()
  return
    --[binary expr start] any
     1
    or
     2
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     1
    or
     2
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	MOV {1 Kint(0)} {T(0)}
	CBR {T(0)} {L3, L2}
L1 (exit)
L2
	MOV {2 Kint(1)} {T(0)}
	BR {L3}
L3
	RET {T(0)} {L1}
return 3 or 4 or 5
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      3
     or
      4
     --[binary expr end]
    or
     5
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      3
     or
      4
     --[binary expr end]
    or
     5
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	MOV {3 Kint(0)} {T(1)}
	CBR {T(1)} {L5, L4}
L1 (exit)
L2
	MOV {5 Kint(2)} {T(0)}
	BR {L3}
L3
	RET {T(0)} {L1}
L4
	MOV {4 Kint(1)} {T(1)}
	BR {L5}
L5
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L3, L2}
return x[1]
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	RET {T(1)} {L1}
L1 (exit)
return x()
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	CALL {T(0)} {T(0..)}
	RET {T(0..)} {L1}
L1 (exit)
return x[1]()
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
       --[function call start] any
        (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
       --[function call start] any
        (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	CALL {T(1)} {T(1..)}
	RET {T(1..)} {L1}
L1 (exit)
return x[1]:name()
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
       --[function call start] any
        : name (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
       --[function call start] any
        : name (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	GETsk {T(1), 'name' Ks(1)} {T(2)}
	CALL {T(2), T(1)} {T(2..)}
	RET {T(2..)} {L1}
L1 (exit)
return x[1]:name(1,2)
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
       --[function call start] any
        : name (
          1
         ,
          2
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
       --[function call start] any
        : name (
          1
         ,
          2
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	GETsk {T(1), 'name' Ks(1)} {T(2)}
	CALL {T(2), T(1), 1 Kint(0), 2 Kint(2)} {T(2..)}
	RET {T(2..)} {L1}
L1 (exit)
return x(), y()
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
   ,
    --[suffixed expr start] any
     --[primary start] any
       y --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
   ,
    --[suffixed expr start] any
     --[primary start] any
       y --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	CALL {T(0)} {T(0)}
	LOADGLOBAL {y} {T(1)}
	CALL {T(1)} {T(1..)}
	RET {T(0), T(1..)} {L1}
L1 (exit)
return y(x())
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       y --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
          --[suffixed expr start] any
           --[primary start] any
             x --global symbol any 
           --[primary end]
           --[suffix list start]
             --[function call start] any
              (
              )
             --[function call end]
           --[suffix list end]
          --[suffixed expr end]
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       y --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
          --[suffixed expr start] any
           --[primary start] any
             x --global symbol any 
           --[primary end]
           --[suffix list start]
             --[function call start] any
              (
              )
             --[function call end]
           --[suffix list end]
          --[suffixed expr end]
        )
       --[function call end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {y} {T(0)}
	LOADGLOBAL {x} {T(1)}
	CALL {T(1)} {T(1..)}
	CALL {T(0), T(1..)} {T(0..)}
	RET {T(0..)} {L1}
L1 (exit)
x = 1
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	STOREGLOBAL {x, 1 Kint(0)}
	BR {L1}
L1 (exit)
x = 1, 2
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
    ,
     2
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
    ,
     2
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	STOREGLOBAL {x, 2 Kint(1)}
	BR {L1}
L1 (exit)
x[1] = 1
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	PUTik {T(0), 1 Kint(0), 1 Kint(0)}
	BR {L1}
L1 (exit)
x[1] = b
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        b --global symbol any 
      --[primary end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        b --global symbol any 
      --[primary end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	LOADGLOBAL {b} {T(2)}
	PUTik {T(0), 1 Kint(0), T(2)}
	BR {L1}
L1 (exit)
x[1][1] = b
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        b --global symbol any 
      --[primary end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        b --global symbol any 
      --[primary end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	LOADGLOBAL {b} {T(3)}
	PUTik {T(1), 1 Kint(0), T(3)}
	BR {L1}
L1 (exit)
x()
function()
  --[expression statement start]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	CALL {T(0)} {T(0..)}
	BR {L1}
L1 (exit)
x()[1]
function()
  --[expression statement start]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	CALL {T(0)} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	BR {L1}
L1 (exit)
x()[1](a,b)
function()
  --[expression statement start]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
        --[function call start] any
         (
           --[suffixed expr start] any
            --[primary start] any
              a --global symbol any 
            --[primary end]
           --[suffixed expr end]
          ,
           --[suffixed expr start] any
            --[primary start] any
              b --global symbol any 
            --[primary end]
           --[suffixed expr end]
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
        --[function call start] any
         (
           --[suffixed expr start] any
            --[primary start] any
              a --global symbol any 
            --[primary end]
           --[suffixed expr end]
          ,
           --[suffixed expr start] any
            --[primary start] any
              b --global symbol any 
            --[primary end]
           --[suffixed expr end]
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	CALL {T(0)} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	LOADGLOBAL {a} {T(2)}
	LOADGLOBAL {b} {T(3)}
	CALL {T(1), T(2), T(3)} {T(1..)}
	BR {L1}
L1 (exit)
x,y = 1,2
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
    ,
     2
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
    ,
     2
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	STOREGLOBAL {y, 2 Kint(1)}
	STOREGLOBAL {x, 1 Kint(0)}
	BR {L1}
L1 (exit)
x,y = f()
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        f --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        f --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {f} {T(2)}
	CALL {T(2)} {T(2..)}
	STOREGLOBAL {y, T(3[2..])}
	STOREGLOBAL {x, T(2[2..])}
	BR {L1}
L1 (exit)
x[1],y[1],c,d = 1,z()
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        c --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        d --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
    ,
     --[suffixed expr start] any
      --[primary start] any
        z --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        c --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        d --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
    ,
     --[suffixed expr start] any
      --[primary start] any
        z --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	LOADGLOBAL {y} {T(2)}
	LOADGLOBAL {z} {T(6)}
	CALL {T(6)} {T(6..)}
	STOREGLOBAL {d, T(8[6..])}
	STOREGLOBAL {c, T(7[6..])}
	PUTik {T(2), 1 Kint(0), T(6[6..])}
	PUTik {T(0), 1 Kint(0), 1 Kint(0)}
	BR {L1}
L1 (exit)
x[1][2],y[1],c,d = 1,z()
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
        --[Y index start] any
         [
          2
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        c --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        d --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
    ,
     --[suffixed expr start] any
      --[primary start] any
        z --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
        --[Y index start] any
         [
          2
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        c --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        d --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
    ,
     --[suffixed expr start] any
      --[primary start] any
        z --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	LOADGLOBAL {y} {T(3)}
	LOADGLOBAL {z} {T(7)}
	CALL {T(7)} {T(7..)}
	STOREGLOBAL {d, T(9[7..])}
	STOREGLOBAL {c, T(8[7..])}
	PUTik {T(3), 1 Kint(0), T(7[7..])}
	PUTik {T(1), 2 Kint(1), 1 Kint(0)}
	BR {L1}
L1 (exit)
x,y = y,x
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {y} {T(2)}
	LOADGLOBAL {x} {T(3)}
	STOREGLOBAL {y, T(3)}
	STOREGLOBAL {x, T(2)}
	BR {L1}
L1 (exit)
x,y,z = z,y,x
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        z --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        z --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        z --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        z --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {z} {T(3)}
	LOADGLOBAL {y} {T(4)}
	LOADGLOBAL {x} {T(5)}
	STOREGLOBAL {z, T(5)}
	STOREGLOBAL {y, T(4)}
	STOREGLOBAL {x, T(3)}
	BR {L1}
L1 (exit)
i = 3; i, a[i] = i+1, 20
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        i --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     3
   --[expression list end]
  --[expression statement end]
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        i --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        a --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          --[suffixed expr start] any
           --[primary start] any
             i --global symbol any 
           --[primary end]
          --[suffixed expr end]
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
         i --global symbol any 
       --[primary end]
      --[suffixed expr end]
     +
      1
     --[binary expr end]
    ,
     20
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        i --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     3
   --[expression list end]
  --[expression statement end]
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        i --global symbol any 
      --[primary end]
     --[suffixed expr end]
    ,
     --[suffixed expr start] any
      --[primary start] any
        a --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          --[suffixed expr start] any
           --[primary start] any
             i --global symbol any 
           --[primary end]
          --[suffixed expr end]
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
         i --global symbol any 
       --[primary end]
      --[suffixed expr end]
     +
      1
     --[binary expr end]
    ,
     20
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	STOREGLOBAL {i, 3 Kint(0)}
	LOADGLOBAL {a} {T(1)}
	LOADGLOBAL {i} {T(2)}
	LOADGLOBAL {i} {T(4)}
	ADD {T(4), 1 Kint(1)} {T(5)}
	PUT {T(1), T(2), 20 Kint(2)}
	STOREGLOBAL {i, T(5)}
	BR {L1}
L1 (exit)
x(y(a[10],5,z()))[1] = 9
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
           --[suffixed expr start] any
            --[primary start] any
              y --global symbol any 
            --[primary end]
            --[suffix list start]
              --[function call start] any
               (
                 --[suffixed expr start] any
                  --[primary start] any
                    a --global symbol any 
                  --[primary end]
                  --[suffix list start]
                    --[Y index start] any
                     [
                      10
                     ]
                    --[Y index end]
                  --[suffix list end]
                 --[suffixed expr end]
                ,
                 5
                ,
                 --[suffixed expr start] any
                  --[primary start] any
                    z --global symbol any 
                  --[primary end]
                  --[suffix list start]
                    --[function call start] any
                     (
                     )
                    --[function call end]
                  --[suffix list end]
                 --[suffixed expr end]
               )
              --[function call end]
            --[suffix list end]
           --[suffixed expr end]
         )
        --[function call end]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     9
   --[expression list end]
  --[expression statement end]
end
function()
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        x --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
           --[suffixed expr start] any
            --[primary start] any
              y --global symbol any 
            --[primary end]
            --[suffix list start]
              --[function call start] any
               (
                 --[suffixed expr start] any
                  --[primary start] any
                    a --global symbol any 
                  --[primary end]
                  --[suffix list start]
                    --[Y index start] any
                     [
                      10
                     ]
                    --[Y index end]
                  --[suffix list end]
                 --[suffixed expr end]
                ,
                 5
                ,
                 --[suffixed expr start] any
                  --[primary start] any
                    z --global symbol any 
                  --[primary end]
                  --[suffix list start]
                    --[function call start] any
                     (
                     )
                    --[function call end]
                  --[suffix list end]
                 --[suffixed expr end]
               )
              --[function call end]
            --[suffix list end]
           --[suffixed expr end]
         )
        --[function call end]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     9
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	LOADGLOBAL {y} {T(1)}
	LOADGLOBAL {a} {T(2)}
	GETik {T(2), 10 Kint(0)} {T(3)}
	LOADGLOBAL {z} {T(4)}
	CALL {T(4)} {T(4..)}
	CALL {T(1), T(3), 5 Kint(1), T(4..)} {T(1..)}
	CALL {T(0), T(1..)} {T(0)}
	PUTik {T(0), 1 Kint(2), 9 Kint(3)}
	BR {L1}
L1 (exit)
local i = 0
function()
--locals  i
  local
  --[symbols]
    i --local symbol any 
  --[expressions]
    0
end
function()
--locals  i
  local
  --[symbols]
    i --local symbol any 
  --[expressions]
    0
end
define Proc(0)
L0 (entry)
	MOV {0 Kint(0)} {local(i, 0)}
	BR {L1}
L1 (exit)
local i, j = 1, 2
function()
--locals  i, j
  local
  --[symbols]
    i --local symbol any 
   ,
    j --local symbol any 
  --[expressions]
    1
   ,
    2
end
function()
--locals  i, j
  local
  --[symbols]
    i --local symbol any 
   ,
    j --local symbol any 
  --[expressions]
    1
   ,
    2
end
define Proc(0)
L0 (entry)
	MOV {2 Kint(1)} {local(j, 1)}
	MOV {1 Kint(0)} {local(i, 0)}
	BR {L1}
L1 (exit)
local a = a
function()
--locals  a
  local
  --[symbols]
    a --local symbol any 
  --[expressions]
    --[suffixed expr start] any
     --[primary start] any
       a --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
function()
--locals  a
  local
  --[symbols]
    a --local symbol any 
  --[expressions]
    --[suffixed expr start] any
     --[primary start] any
       a --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {a} {T(0)}
	MOV {T(0)} {local(a, 0)}
	BR {L1}
L1 (exit)
local a = b
function()
--locals  a
  local
  --[symbols]
    a --local symbol any 
  --[expressions]
    --[suffixed expr start] any
     --[primary start] any
       b --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
function()
--locals  a
  local
  --[symbols]
    a --local symbol any 
  --[expressions]
    --[suffixed expr start] any
     --[primary start] any
       b --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {b} {T(0)}
	MOV {T(0)} {local(a, 0)}
	BR {L1}
L1 (exit)
local a, b = x, y
function()
--locals  a, b
  local
  --[symbols]
    a --local symbol any 
   ,
    b --local symbol any 
  --[expressions]
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
    --[suffixed expr end]
   ,
    --[suffixed expr start] any
     --[primary start] any
       y --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
function()
--locals  a, b
  local
  --[symbols]
    a --local symbol any 
   ,
    b --local symbol any 
  --[expressions]
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
    --[suffixed expr end]
   ,
    --[suffixed expr start] any
     --[primary start] any
       y --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	LOADGLOBAL {y} {T(1)}
	MOV {T(1)} {local(b, 1)}
	MOV {T(0)} {local(a, 0)}
	BR {L1}
L1 (exit)
local a: integer return a+3
function()
--locals  a
  local
  --[symbols]
    a --local symbol integer 
  return
    --[binary expr start] any
     --[suffixed expr start] integer
      --[primary start] integer
        a --local symbol integer 
      --[primary end]
     --[suffixed expr end]
    +
     3
    --[binary expr end]
end
function()
--locals  a
  local
  --[symbols]
    a --local symbol integer 
  return
    --[binary expr start] integer
     --[suffixed expr start] integer
      --[primary start] integer
        a --local symbol integer 
      --[primary end]
     --[suffixed expr end]
    +
     3
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	ADDii {local(a, 0), 3 Kint(0)} {Tint(0)}
	RET {Tint(0)} {L1}
L1 (exit)
local i: integer; return t[i/5]
function()
--locals  i
  local
  --[symbols]
    i --local symbol integer 
  return
    --[suffixed expr start] any
     --[primary start] any
       t --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         --[binary expr start] any
          --[suffixed expr start] integer
           --[primary start] integer
             i --local symbol integer 
           --[primary end]
          --[suffixed expr end]
         /
          5
         --[binary expr end]
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
--locals  i
  local
  --[symbols]
    i --local symbol integer 
  return
    --[suffixed expr start] any
     --[primary start] any
       t --global symbol any 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         --[binary expr start] number
          --[suffixed expr start] integer
           --[primary start] integer
             i --local symbol integer 
           --[primary end]
          --[suffixed expr end]
         /
          5
         --[binary expr end]
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {t} {T(0)}
	DIVii {local(i, 0), 5 Kint(0)} {Tflt(0)}
	GET {T(0), Tflt(0)} {T(1)}
	RET {T(1)} {L1}
L1 (exit)
local t: integer[]; return t[0]
function()
--locals  t
  local
  --[symbols]
    t --local symbol integer[] 
  return
    --[suffixed expr start] any
     --[primary start] integer[]
       t --local symbol integer[] 
     --[primary end]
     --[suffix list start]
       --[Y index start] any
        [
         0
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
--locals  t
  local
  --[symbols]
    t --local symbol integer[] 
  return
    --[suffixed expr start] integer
     --[primary start] integer[]
       t --local symbol integer[] 
     --[primary end]
     --[suffix list start]
       --[Y index start] integer
        [
         0
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	IAGETik {local(t, 0), 0 Kint(0)} {Tint(0)}
	RET {Tint(0)} {L1}
L1 (exit)
return f()[1]
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       f --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
        )
       --[function call end]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       f --global symbol any 
     --[primary end]
     --[suffix list start]
       --[function call start] any
        (
        )
       --[function call end]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {f} {T(0)}
	CALL {T(0)} {T(0)}
	GETik {T(0), 1 Kint(0)} {T(1)}
	RET {T(1)} {L1}
L1 (exit)
return x.y[1]
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[field selector start] any
        .
         'y'
       --[field selector end]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
function()
  return
    --[suffixed expr start] any
     --[primary start] any
       x --global symbol any 
     --[primary end]
     --[suffix list start]
       --[field selector start] any
        .
         'y'
       --[field selector end]
       --[Y index start] any
        [
         1
        ]
       --[Y index end]
     --[suffix list end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {x} {T(0)}
	GETsk {T(0), 'y' Ks(0)} {T(1)}
	GETik {T(1), 1 Kint(1)} {T(2)}
	RET {T(2)} {L1}
L1 (exit)
local t: integer[] if (t[1] == 5) then return true end return false
function()
--locals  t
  local
  --[symbols]
    t --local symbol integer[] 
  if
   --[suffixed expr start] any
    --[primary start] any
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] integer[]
         t --local symbol integer[] 
       --[primary end]
       --[suffix list start]
         --[Y index start] any
          [
           1
          ]
         --[Y index end]
       --[suffix list end]
      --[suffixed expr end]
     ==
      5
     --[binary expr end]
    --[primary end]
   --[suffixed expr end]
  then
    return
      true
  end
  return
    false
end
function()
--locals  t
  local
  --[symbols]
    t --local symbol integer[] 
  if
   --[suffixed expr start] boolean
    --[primary start] boolean
     --[binary expr start] boolean
      --[suffixed expr start] integer
       --[primary start] integer[]
         t --local symbol integer[] 
       --[primary end]
       --[suffix list start]
         --[Y index start] integer
          [
           1
          ]
         --[Y index end]
       --[suffix list end]
      --[suffixed expr end]
     ==
      5
     --[binary expr end]
    --[primary end]
   --[suffixed expr end]
  then
    return
      true
  end
  return
    false
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	IAGETik {local(t, 0), 1 Kint(0)} {Tint(0)}
	EQii {Tint(0), 5 Kint(1)} {T(0)}
	CBR {T(0)} {L3, L4}
L3
	RET {true} {L1}
L4
	RET {false} {L1}
local t: table local len: integer = #t return len
function()
--locals  t, len
  local
  --[symbols]
    t --local symbol table 
  local
  --[symbols]
    len --local symbol integer 
  --[expressions]
    --[unary expr start] any
    #
     --[suffixed expr start] table
      --[primary start] table
        t --local symbol table 
      --[primary end]
     --[suffixed expr end]
    --[unary expr end]
  return
    --[suffixed expr start] integer
     --[primary start] integer
       len --local symbol integer 
     --[primary end]
    --[suffixed expr end]
end
function()
--locals  t, len
  local
  --[symbols]
    t --local symbol table 
  local
  --[symbols]
    len --local symbol integer 
  --[expressions]
    --[unary expr start] any
    #
     --[suffixed expr start] table
      --[primary start] table
        t --local symbol table 
      --[primary end]
     --[suffixed expr end]
    --[unary expr end]
  return
    --[suffixed expr start] integer
     --[primary start] integer
       len --local symbol integer 
     --[primary end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	LEN {local(t, 0)} {T(0)}
	MOV {T(0)} {local(len, 1)}
	RET {local(len, 1)} {L1}
L1 (exit)
return function(t: table, i: integer) i = #t end
function()
  return
    function(
      t --local symbol table 
     ,
      i --local symbol integer 
    )
    --locals  t, i
      --[expression statement start]
       --[var list start]
         --[suffixed expr start] integer
          --[primary start] integer
            i --local symbol integer 
          --[primary end]
         --[suffixed expr end]
       = --[var list end]
       --[expression list start]
         --[unary expr start] any
         #
          --[suffixed expr start] table
           --[primary start] table
             t --local symbol table 
           --[primary end]
          --[suffixed expr end]
         --[unary expr end]
       --[expression list end]
      --[expression statement end]
    end
end
function()
  return
    function(
      t --local symbol table 
     ,
      i --local symbol integer 
    )
    --locals  t, i
      --[expression statement start]
       --[var list start]
         --[suffixed expr start] integer
          --[primary start] integer
            i --local symbol integer 
          --[primary end]
         --[suffixed expr end]
       = --[var list end]
       --[expression list start]
         --[unary expr start] any
         #
          --[suffixed expr start] table
           --[primary start] table
             t --local symbol table 
           --[primary end]
          --[suffixed expr end]
         --[unary expr end]
       --[expression list end]
      --[expression statement end]
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	TOTABLE {local(t, 0)}
	TOINT {local(i, 1)}
	LEN {local(t, 0)} {T(0)}
	MOV {T(0)} {local(i, 1)}
	BR {L1}
L1 (exit)
::L1:: a = 1; goto L1; return
function()
  ::L1::
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        a --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
   --[expression list end]
  --[expression statement end]
  goto L1
  return
end
function()
  ::L1::
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        a --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
   --[expression list end]
  --[expression statement end]
  goto L1
  return
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	STOREGLOBAL {a, 1 Kint(0)}
	BR {L2}
L3
	RET {L1}
::l1:: do goto l1; x = 1; ::l1:: z = 2 end y = 1; goto l1
function()
  ::l1::
  do
    goto l1
    --[expression statement start]
     --[var list start]
       --[suffixed expr start] any
        --[primary start] any
          x --global symbol any 
        --[primary end]
       --[suffixed expr end]
     = --[var list end]
     --[expression list start]
       1
     --[expression list end]
    --[expression statement end]
    ::l1::
    --[expression statement start]
     --[var list start]
       --[suffixed expr start] any
        --[primary start] any
          z --global symbol any 
        --[primary end]
       --[suffixed expr end]
     = --[var list end]
     --[expression list start]
       2
     --[expression list end]
    --[expression statement end]
  end
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
   --[expression list end]
  --[expression statement end]
  goto l1
end
function()
  ::l1::
  do
    goto l1
    --[expression statement start]
     --[var list start]
       --[suffixed expr start] any
        --[primary start] any
          x --global symbol any 
        --[primary end]
       --[suffixed expr end]
     = --[var list end]
     --[expression list start]
       1
     --[expression list end]
    --[expression statement end]
    ::l1::
    --[expression statement start]
     --[var list start]
       --[suffixed expr start] any
        --[primary start] any
          z --global symbol any 
        --[primary end]
       --[suffixed expr end]
     = --[var list end]
     --[expression list start]
       2
     --[expression list end]
    --[expression statement end]
  end
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        y --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     1
   --[expression list end]
  --[expression statement end]
  goto l1
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	BR {L4}
L3
	STOREGLOBAL {x, 1 Kint(0)}
	BR {L4}
L4
	STOREGLOBAL {z, 2 Kint(1)}
	STOREGLOBAL {y, 1 Kint(0)}
	BR {L2}
L5
	BR {L1}
goto l1; do ::l1:: end
function()
  goto l1
  do
    ::l1::
  end
end
function()
  goto l1
  do
    ::l1::
  end
end
return function()
    local a = 1

	local function y()
		return function()
			return a
		end
	end

	local a = 5

	local function z()
		return function()
			return a
		end
	end

	return y, z
end
function()
  return
    function()
    --locals  a, y, a, z
      local
      --[symbols]
        a --local symbol any 
      --[expressions]
        1
      local
      --[symbols]
        y --local symbol closure 
      --[expressions]
        function()
        --upvalues  a
          return
            function()
            --upvalues  a
              return
                --[suffixed expr start] any
                 --[primary start] any
                   a --upvalue any 
                 --[primary end]
                --[suffixed expr end]
            end
        end
      local
      --[symbols]
        a --local symbol any 
      --[expressions]
        5
      local
      --[symbols]
        z --local symbol closure 
      --[expressions]
        function()
        --upvalues  a
          return
            function()
            --upvalues  a
              return
                --[suffixed expr start] any
                 --[primary start] any
                   a --upvalue any 
                 --[primary end]
                --[suffixed expr end]
            end
        end
      return
        --[suffixed expr start] closure
         --[primary start] closure
           y --local symbol closure 
         --[primary end]
        --[suffixed expr end]
       ,
        --[suffixed expr start] closure
         --[primary start] closure
           z --local symbol closure 
         --[primary end]
        --[suffixed expr end]
    end
end
function()
  return
    function()
    --locals  a, y, a, z
      local
      --[symbols]
        a --local symbol any 
      --[expressions]
        1
      local
      --[symbols]
        y --local symbol closure 
      --[expressions]
        function()
        --upvalues  a
          return
            function()
            --upvalues  a
              return
                --[suffixed expr start] any
                 --[primary start] any
                   a --upvalue any 
                 --[primary end]
                --[suffixed expr end]
            end
        end
      local
      --[symbols]
        a --local symbol any 
      --[expressions]
        5
      local
      --[symbols]
        z --local symbol closure 
      --[expressions]
        function()
        --upvalues  a
          return
            function()
            --upvalues  a
              return
                --[suffixed expr start] any
                 --[primary start] any
                   a --upvalue any 
                 --[primary end]
                --[suffixed expr end]
            end
        end
      return
        --[suffixed expr start] closure
         --[primary start] closure
           y --local symbol closure 
         --[primary end]
        --[suffixed expr end]
       ,
        --[suffixed expr start] closure
         --[primary start] closure
           z --local symbol closure 
         --[primary end]
        --[suffixed expr end]
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	MOV {1 Kint(0)} {local(a, 0)}
	CLOSURE {Proc(2)} {T(0)}
	MOV {T(0)} {local(y, 1)}
	MOV {5 Kint(1)} {local(a, 2)}
	CLOSURE {Proc(4)} {T(0)}
	MOV {T(0)} {local(z, 3)}
	RET {local(y, 1), local(z, 3)} {L1}
L1 (exit)
define Proc(2)
L0 (entry)
	CLOSURE {Proc(3)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(3)
L0 (entry)
	RET {Upval(0)} {L1}
L1 (exit)
define Proc(4)
L0 (entry)
	CLOSURE {Proc(5)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(5)
L0 (entry)
	RET {Upval(0)} {L1}
L1 (exit)
return function (a, b, c, d, e)
    if a == b then goto l1
    elseif a == c then goto l2
    elseif a == d then goto l2
    else if a == e then goto l3
        else goto l3
        end
    end
    ::l1:: ::l2:: ::l3:: ::l4::
end
function()
  return
    function(
      a --local symbol any 
     ,
      b --local symbol any 
     ,
      c --local symbol any 
     ,
      d --local symbol any 
     ,
      e --local symbol any 
    )
    --locals  a, b, c, d, e
      if
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           a --local symbol any 
         --[primary end]
        --[suffixed expr end]
       ==
        --[suffixed expr start] any
         --[primary start] any
           b --local symbol any 
         --[primary end]
        --[suffixed expr end]
       --[binary expr end]
      then
        goto l1
      elseif
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           a --local symbol any 
         --[primary end]
        --[suffixed expr end]
       ==
        --[suffixed expr start] any
         --[primary start] any
           c --local symbol any 
         --[primary end]
        --[suffixed expr end]
       --[binary expr end]
      then
        goto l2
      elseif
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           a --local symbol any 
         --[primary end]
        --[suffixed expr end]
       ==
        --[suffixed expr start] any
         --[primary start] any
           d --local symbol any 
         --[primary end]
        --[suffixed expr end]
       --[binary expr end]
      then
        goto l2
      else
        if
         --[binary expr start] any
          --[suffixed expr start] any
           --[primary start] any
             a --local symbol any 
           --[primary end]
          --[suffixed expr end]
         ==
          --[suffixed expr start] any
           --[primary start] any
             e --local symbol any 
           --[primary end]
          --[suffixed expr end]
         --[binary expr end]
        then
          goto l3
        else
          goto l3
        end
      end
      ::l1::
      ::l2::
      ::l3::
      ::l4::
    end
end
function()
  return
    function(
      a --local symbol any 
     ,
      b --local symbol any 
     ,
      c --local symbol any 
     ,
      d --local symbol any 
     ,
      e --local symbol any 
    )
    --locals  a, b, c, d, e
      if
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           a --local symbol any 
         --[primary end]
        --[suffixed expr end]
       ==
        --[suffixed expr start] any
         --[primary start] any
           b --local symbol any 
         --[primary end]
        --[suffixed expr end]
       --[binary expr end]
      then
        goto l1
      elseif
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           a --local symbol any 
         --[primary end]
        --[suffixed expr end]
       ==
        --[suffixed expr start] any
         --[primary start] any
           c --local symbol any 
         --[primary end]
        --[suffixed expr end]
       --[binary expr end]
      then
        goto l2
      elseif
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           a --local symbol any 
         --[primary end]
        --[suffixed expr end]
       ==
        --[suffixed expr start] any
         --[primary start] any
           d --local symbol any 
         --[primary end]
        --[suffixed expr end]
       --[binary expr end]
      then
        goto l2
      else
        if
         --[binary expr start] any
          --[suffixed expr start] any
           --[primary start] any
             a --local symbol any 
           --[primary end]
          --[suffixed expr end]
         ==
          --[suffixed expr start] any
           --[primary start] any
             e --local symbol any 
           --[primary end]
          --[suffixed expr end]
         --[binary expr end]
        then
          goto l3
        else
          goto l3
        end
      end
      ::l1::
      ::l2::
      ::l3::
      ::l4::
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	EQ {local(a, 0), local(b, 1)} {T(0)}
	CBR {T(0)} {L5, L3}
L3
	EQ {local(a, 0), local(c, 2)} {T(1)}
	CBR {T(1)} {L6, L4}
L4
	EQ {local(a, 0), local(d, 3)} {T(2)}
	CBR {T(2)} {L7, L8}
L5
	BR {L19}
L6
	BR {L20}
L7
	BR {L20}
L8
	BR {L13}
L9
	BR {L19}
L10
	BR {L9}
L11
	BR {L9}
L12
	BR {L9}
L13
	EQ {local(a, 0), local(e, 4)} {T(3)}
	CBR {T(3)} {L14, L15}
L14
	BR {L21}
L15
	BR {L21}
L16
	BR {L9}
L17
	BR {L16}
L18
	BR {L16}
L19
	BR {L20}
L20
	BR {L21}
L21
	BR {L22}
L22
	BR {L1}
return function (a) while a < 10 do a = a + 1 end end
function()
  return
    function(
      a --local symbol any 
    )
    --locals  a
      while
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           a --local symbol any 
         --[primary end]
        --[suffixed expr end]
       <
        10
       --[binary expr end]
      do
        --[expression statement start]
         --[var list start]
           --[suffixed expr start] any
            --[primary start] any
              a --local symbol any 
            --[primary end]
           --[suffixed expr end]
         = --[var list end]
         --[expression list start]
           --[binary expr start] any
            --[suffixed expr start] any
             --[primary start] any
               a --local symbol any 
             --[primary end]
            --[suffixed expr end]
           +
            1
           --[binary expr end]
         --[expression list end]
        --[expression statement end]
      end
    end
end
function()
  return
    function(
      a --local symbol any 
    )
    --locals  a
      while
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           a --local symbol any 
         --[primary end]
        --[suffixed expr end]
       <
        10
       --[binary expr end]
      do
        --[expression statement start]
         --[var list start]
           --[suffixed expr start] any
            --[primary start] any
              a --local symbol any 
            --[primary end]
           --[suffixed expr end]
         = --[var list end]
         --[expression list start]
           --[binary expr start] any
            --[suffixed expr start] any
             --[primary start] any
               a --local symbol any 
             --[primary end]
            --[suffixed expr end]
           +
            1
           --[binary expr end]
         --[expression list end]
        --[expression statement end]
      end
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	LT {local(a, 0), 10 Kint(0)} {T(0)}
	CBR {T(0)} {L3, L4}
L3
	ADD {local(a, 0), 1 Kint(1)} {T(0)}
	MOV {T(0)} {local(a, 0)}
	BR {L2}
L4
	BR {L1}
return function (a) ::L2:: if not(a < 10) then goto L1 end; a = a + 1;
                  goto L2; ::L1:: end
function()
  return
    function(
      a --local symbol any 
    )
    --locals  a
      ::L2::
      if
       --[unary expr start] any
       not
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           --[suffixed expr start] any
            --[primary start] any
              a --local symbol any 
            --[primary end]
           --[suffixed expr end]
          <
           10
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       --[unary expr end]
      then
        goto L1
      end
      --[expression statement start]
       --[var list start]
         --[suffixed expr start] any
          --[primary start] any
            a --local symbol any 
          --[primary end]
         --[suffixed expr end]
       = --[var list end]
       --[expression list start]
         --[binary expr start] any
          --[suffixed expr start] any
           --[primary start] any
             a --local symbol any 
           --[primary end]
          --[suffixed expr end]
         +
          1
         --[binary expr end]
       --[expression list end]
      --[expression statement end]
      goto L2
      ::L1::
    end
end
function()
  return
    function(
      a --local symbol any 
    )
    --locals  a
      ::L2::
      if
       --[unary expr start] any
       not
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           --[suffixed expr start] any
            --[primary start] any
              a --local symbol any 
            --[primary end]
           --[suffixed expr end]
          <
           10
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       --[unary expr end]
      then
        goto L1
      end
      --[expression statement start]
       --[var list start]
         --[suffixed expr start] any
          --[primary start] any
            a --local symbol any 
          --[primary end]
         --[suffixed expr end]
       = --[var list end]
       --[expression list start]
         --[binary expr start] any
          --[suffixed expr start] any
           --[primary start] any
             a --local symbol any 
           --[primary end]
          --[suffixed expr end]
         +
          1
         --[binary expr end]
       --[expression list end]
      --[expression statement end]
      goto L2
      ::L1::
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	BR {L3}
L3
	LT {local(a, 0), 10 Kint(0)} {T(0)}
	NOT {T(0)} {T(1)}
	CBR {T(1)} {L4, L5}
L4
	BR {L8}
L5
	ADD {local(a, 0), 1 Kint(1)} {T(2)}
	MOV {T(2)} {local(a, 0)}
	BR {L2}
L6
	BR {L5}
L7
	BR {L8}
L8
	BR {L1}
return function ()
    (function () end){f()}
  end
function()
  return
    function()
      --[expression statement start]
       --[expression list start]
         --[suffixed expr start] closure
          --[primary start] closure
           function()
           end
          --[primary end]
          --[suffix list start]
            --[function call start] any
             (
               { --[table constructor start] table
                 --[indexed assign start] any
                 --[value start]
                  --[suffixed expr start] any
                   --[primary start] any
                     f --global symbol any 
                   --[primary end]
                   --[suffix list start]
                     --[function call start] any
                      (
                      )
                     --[function call end]
                   --[suffix list end]
                  --[suffixed expr end]
                 --[value end]
                 --[indexed assign end]
               } --[table constructor end]
             )
            --[function call end]
          --[suffix list end]
         --[suffixed expr end]
       --[expression list end]
      --[expression statement end]
    end
end
function()
  return
    function()
      --[expression statement start]
       --[expression list start]
         --[suffixed expr start] any
          --[primary start] closure
           function()
           end
          --[primary end]
          --[suffix list start]
            --[function call start] any
             (
               { --[table constructor start] table
                 --[indexed assign start] any
                 --[value start]
                  --[suffixed expr start] any
                   --[primary start] any
                     f --global symbol any 
                   --[primary end]
                   --[suffix list start]
                     --[function call start] any
                      (
                      )
                     --[function call end]
                   --[suffix list end]
                  --[suffixed expr end]
                 --[value end]
                 --[indexed assign end]
               } --[table constructor end]
             )
            --[function call end]
          --[suffix list end]
         --[suffixed expr end]
       --[expression list end]
      --[expression statement end]
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	CLOSURE {Proc(2)} {T(0)}
	NEWTABLE {T(1)}
	LOADGLOBAL {f} {T(2)}
	CALL {T(2)} {T(2..)}
	TPUTik {T(1), 1 Kint(0), T(2..)}
	CALL {T(0), T(1)} {T(0..)}
	BR {L1}
L1 (exit)
define Proc(2)
L0 (entry)
	BR {L1}
L1 (exit)
return function ()
    local sum 
    for j = 1,500 do
        sum = 0.0
        for k = 1,10000 do
            sum = sum + 1.0/(k*k)
        end
    end
    return sum
end
function()
  return
    function()
    --locals  sum, j, k
      local
      --[symbols]
        sum --local symbol any 
      for
        j --local symbol any 
      =
        1
       ,
        500
      do
         --[expression statement start]
          --[var list start]
            --[suffixed expr start] any
             --[primary start] any
               sum --local symbol any 
             --[primary end]
            --[suffixed expr end]
          = --[var list end]
          --[expression list start]
            0.0000000000000000
          --[expression list end]
         --[expression statement end]
         for
           k --local symbol any 
         =
           1
          ,
           10000
         do
            --[expression statement start]
             --[var list start]
               --[suffixed expr start] any
                --[primary start] any
                  sum --local symbol any 
                --[primary end]
               --[suffixed expr end]
             = --[var list end]
             --[expression list start]
               --[binary expr start] any
                --[suffixed expr start] any
                 --[primary start] any
                   sum --local symbol any 
                 --[primary end]
                --[suffixed expr end]
               +
                --[binary expr start] any
                 1.0000000000000000
                /
                 --[suffixed expr start] any
                  --[primary start] any
                   --[binary expr start] any
                    --[suffixed expr start] any
                     --[primary start] any
                       k --local symbol any 
                     --[primary end]
                    --[suffixed expr end]
                   *
                    --[suffixed expr start] any
                     --[primary start] any
                       k --local symbol any 
                     --[primary end]
                    --[suffixed expr end]
                   --[binary expr end]
                  --[primary end]
                 --[suffixed expr end]
                --[binary expr end]
               --[binary expr end]
             --[expression list end]
            --[expression statement end]
         end
      end
      return
        --[suffixed expr start] any
         --[primary start] any
           sum --local symbol any 
         --[primary end]
        --[suffixed expr end]
    end
end
function()
  return
    function()
    --locals  sum, j, k
      local
      --[symbols]
        sum --local symbol any 
      for
        j --local symbol integer 
      =
        1
       ,
        500
      do
         --[expression statement start]
          --[var list start]
            --[suffixed expr start] any
             --[primary start] any
               sum --local symbol any 
             --[primary end]
            --[suffixed expr end]
          = --[var list end]
          --[expression list start]
            0.0000000000000000
          --[expression list end]
         --[expression statement end]
         for
           k --local symbol integer 
         =
           1
          ,
           10000
         do
            --[expression statement start]
             --[var list start]
               --[suffixed expr start] any
                --[primary start] any
                  sum --local symbol any 
                --[primary end]
               --[suffixed expr end]
             = --[var list end]
             --[expression list start]
               --[binary expr start] any
                --[suffixed expr start] any
                 --[primary start] any
                   sum --local symbol any 
                 --[primary end]
                --[suffixed expr end]
               +
                --[binary expr start] number
                 1.0000000000000000
                /
                 --[suffixed expr start] integer
                  --[primary start] integer
                   --[binary expr start] integer
                    --[suffixed expr start] integer
                     --[primary start] integer
                       k --local symbol integer 
                     --[primary end]
                    --[suffixed expr end]
                   *
                    --[suffixed expr start] integer
                     --[primary start] integer
                       k --local symbol integer 
                     --[primary end]
                    --[suffixed expr end]
                   --[binary expr end]
                  --[primary end]
                 --[suffixed expr end]
                --[binary expr end]
               --[binary expr end]
             --[expression list end]
            --[expression statement end]
         end
      end
      return
        --[suffixed expr start] any
         --[primary start] any
           sum --local symbol any 
         --[primary end]
        --[suffixed expr end]
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	MOV {1 Kint(0)} {Tint(0)}
	MOV {500 Kint(1)} {Tint(1)}
	MOV {1 Kint(0)} {Tint(2)}
	LIii {0 Kint(2), Tint(2)} {Tint(3)}
	SUBii {Tint(0), Tint(2)} {Tint(0)}
	BR {L2}
L1 (exit)
L2
	ADDii {Tint(0), Tint(2)} {Tint(0)}
	CBR {Tint(3)} {L3, L4}
L3
	LEii {Tint(1), Tint(0)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L4
	LIii {Tint(0), Tint(1)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L5
	MOV {Tint(0)} {local(j, 1)}
	MOV {0 Kint(2)} {local(sum, 0)}
	MOV {1 Kint(0)} {Tint(5)}
	MOV {10000 Kint(3)} {Tint(6)}
	MOV {1 Kint(0)} {Tint(7)}
	LIii {0 Kint(2), Tint(7)} {Tint(8)}
	SUBii {Tint(5), Tint(7)} {Tint(5)}
	BR {L7}
L6
	RET {local(sum, 0)} {L1}
L7
	ADDii {Tint(5), Tint(7)} {Tint(5)}
	CBR {Tint(8)} {L8, L9}
L8
	LEii {Tint(6), Tint(5)} {Tint(9)}
	CBR {Tint(9)} {L11, L10}
L9
	LIii {Tint(5), Tint(6)} {Tint(9)}
	CBR {Tint(9)} {L11, L10}
L10
	MOV {Tint(5)} {local(k, 2)}
	MULii {local(k, 2), local(k, 2)} {Tint(10)}
	DIVfi {1 Kint(0), Tint(10)} {Tflt(0)}
	ADD {local(sum, 0), Tflt(0)} {T(0)}
	MOV {T(0)} {local(sum, 0)}
	BR {L7}
L11
	BR {L2}
function matmul(a: table, b: table)
  	assert(@integer(#a[1]) == #b);
  	local m: integer, n: integer, p: integer, x: table = #a, #a[1], #b[1], {};
  	local c: table = matrix.T(b); -- transpose for efficiency
  	for i = 1, m do
  		local xi: number[] = table.numarray(p, 0.0)
  		x[i] = xi
  		for j = 1, p do
  			local sum: number, ai: number[], cj: number[] = 0.0, @number[](a[i]), @number[](c[j]);
  			-- for luajit, caching c[j] or not makes no difference; lua is not so clever
  			for k = 1, n do sum = sum + ai[k] * cj[k] end
  			xi[j] = sum;
  		end
  	end
  	return x
  end
return matmul
function()
   matmul --global symbol any 
   =
    function(
      a --local symbol table 
     ,
      b --local symbol table 
    )
    --locals  a, b, m, n, p, x, c, i, xi, j, sum, ai, cj, k
      --[expression statement start]
       --[expression list start]
         --[suffixed expr start] any
          --[primary start] any
            assert --global symbol any 
          --[primary end]
          --[suffix list start]
            --[function call start] any
             (
               --[binary expr start] any
                --[unary expr start] any
                @integer
                 --[suffixed expr start] any
                  --[primary start] any
                   --[unary expr start] any
                   #
                    --[suffixed expr start] any
                     --[primary start] table
                       a --local symbol table 
                     --[primary end]
                     --[suffix list start]
                       --[Y index start] any
                        [
                         1
                        ]
                       --[Y index end]
                     --[suffix list end]
                    --[suffixed expr end]
                   --[unary expr end]
                  --[primary end]
                 --[suffixed expr end]
                --[unary expr end]
               ==
                --[unary expr start] any
                #
                 --[suffixed expr start] table
                  --[primary start] table
                    b --local symbol table 
                  --[primary end]
                 --[suffixed expr end]
                --[unary expr end]
               --[binary expr end]
             )
            --[function call end]
          --[suffix list end]
         --[suffixed expr end]
       --[expression list end]
      --[expression statement end]
      local
      --[symbols]
        m --local symbol integer 
       ,
        n --local symbol integer 
       ,
        p --local symbol integer 
       ,
        x --local symbol table 
      --[expressions]
        --[unary expr start] any
        #
         --[suffixed expr start] table
          --[primary start] table
            a --local symbol table 
          --[primary end]
         --[suffixed expr end]
        --[unary expr end]
       ,
        --[unary expr start] any
        #
         --[suffixed expr start] any
          --[primary start] table
            a --local symbol table 
          --[primary end]
          --[suffix list start]
            --[Y index start] any
             [
              1
             ]
            --[Y index end]
          --[suffix list end]
         --[suffixed expr end]
        --[unary expr end]
       ,
        --[unary expr start] any
        #
         --[suffixed expr start] any
          --[primary start] table
            b --local symbol table 
          --[primary end]
          --[suffix list start]
            --[Y index start] any
             [
              1
             ]
            --[Y index end]
          --[suffix list end]
         --[suffixed expr end]
        --[unary expr end]
       ,
        { --[table constructor start] table
        } --[table constructor end]
      local
      --[symbols]
        c --local symbol table 
      --[expressions]
        --[suffixed expr start] any
         --[primary start] any
           matrix --global symbol any 
         --[primary end]
         --[suffix list start]
           --[field selector start] any
            .
             'T'
           --[field selector end]
           --[function call start] any
            (
              --[suffixed expr start] table
               --[primary start] table
                 b --local symbol table 
               --[primary end]
              --[suffixed expr end]
            )
           --[function call end]
         --[suffix list end]
        --[suffixed expr end]
      for
        i --local symbol any 
      =
        1
       ,
        --[suffixed expr start] integer
         --[primary start] integer
           m --local symbol integer 
         --[primary end]
        --[suffixed expr end]
      do
         local
         --[symbols]
           xi --local symbol number[] 
         --[expressions]
           --[suffixed expr start] any
            --[primary start] any
              table --global symbol any 
            --[primary end]
            --[suffix list start]
              --[field selector start] any
               .
                'numarray'
              --[field selector end]
              --[function call start] any
               (
                 --[suffixed expr start] integer
                  --[primary start] integer
                    p --local symbol integer 
                  --[primary end]
                 --[suffixed expr end]
                ,
                 0.0000000000000000
               )
              --[function call end]
            --[suffix list end]
           --[suffixed expr end]
         --[expression statement start]
          --[var list start]
            --[suffixed expr start] any
             --[primary start] table
               x --local symbol table 
             --[primary end]
             --[suffix list start]
               --[Y index start] any
                [
                 --[suffixed expr start] any
                  --[primary start] any
                    i --local symbol any 
                  --[primary end]
                 --[suffixed expr end]
                ]
               --[Y index end]
             --[suffix list end]
            --[suffixed expr end]
          = --[var list end]
          --[expression list start]
            --[suffixed expr start] number[]
             --[primary start] number[]
               xi --local symbol number[] 
             --[primary end]
            --[suffixed expr end]
          --[expression list end]
         --[expression statement end]
         for
           j --local symbol any 
         =
           1
          ,
           --[suffixed expr start] integer
            --[primary start] integer
              p --local symbol integer 
            --[primary end]
           --[suffixed expr end]
         do
            local
            --[symbols]
              sum --local symbol number 
             ,
              ai --local symbol number[] 
             ,
              cj --local symbol number[] 
            --[expressions]
              0.0000000000000000
             ,
              --[unary expr start] any
              @number[]
               --[suffixed expr start] any
                --[primary start] any
                 --[suffixed expr start] any
                  --[primary start] table
                    a --local symbol table 
                  --[primary end]
                  --[suffix list start]
                    --[Y index start] any
                     [
                      --[suffixed expr start] any
                       --[primary start] any
                         i --local symbol any 
                       --[primary end]
                      --[suffixed expr end]
                     ]
                    --[Y index end]
                  --[suffix list end]
                 --[suffixed expr end]
                --[primary end]
               --[suffixed expr end]
              --[unary expr end]
             ,
              --[unary expr start] any
              @number[]
               --[suffixed expr start] any
                --[primary start] any
                 --[suffixed expr start] any
                  --[primary start] table
                    c --local symbol table 
                  --[primary end]
                  --[suffix list start]
                    --[Y index start] any
                     [
                      --[suffixed expr start] any
                       --[primary start] any
                         j --local symbol any 
                       --[primary end]
                      --[suffixed expr end]
                     ]
                    --[Y index end]
                  --[suffix list end]
                 --[suffixed expr end]
                --[primary end]
               --[suffixed expr end]
              --[unary expr end]
            for
              k --local symbol any 
            =
              1
             ,
              --[suffixed expr start] integer
               --[primary start] integer
                 n --local symbol integer 
               --[primary end]
              --[suffixed expr end]
            do
               --[expression statement start]
                --[var list start]
                  --[suffixed expr start] number
                   --[primary start] number
                     sum --local symbol number 
                   --[primary end]
                  --[suffixed expr end]
                = --[var list end]
                --[expression list start]
                  --[binary expr start] any
                   --[suffixed expr start] number
                    --[primary start] number
                      sum --local symbol number 
                    --[primary end]
                   --[suffixed expr end]
                  +
                   --[binary expr start] any
                    --[suffixed expr start] any
                     --[primary start] number[]
                       ai --local symbol number[] 
                     --[primary end]
                     --[suffix list start]
                       --[Y index start] any
                        [
                         --[suffixed expr start] any
                          --[primary start] any
                            k --local symbol any 
                          --[primary end]
                         --[suffixed expr end]
                        ]
                       --[Y index end]
                     --[suffix list end]
                    --[suffixed expr end]
                   *
                    --[suffixed expr start] any
                     --[primary start] number[]
                       cj --local symbol number[] 
                     --[primary end]
                     --[suffix list start]
                       --[Y index start] any
                        [
                         --[suffixed expr start] any
                          --[primary start] any
                            k --local symbol any 
                          --[primary end]
                         --[suffixed expr end]
                        ]
                       --[Y index end]
                     --[suffix list end]
                    --[suffixed expr end]
                   --[binary expr end]
                  --[binary expr end]
                --[expression list end]
               --[expression statement end]
            end
            --[expression statement start]
             --[var list start]
               --[suffixed expr start] any
                --[primary start] number[]
                  xi --local symbol number[] 
                --[primary end]
                --[suffix list start]
                  --[Y index start] any
                   [
                    --[suffixed expr start] any
                     --[primary start] any
                       j --local symbol any 
                     --[primary end]
                    --[suffixed expr end]
                   ]
                  --[Y index end]
                --[suffix list end]
               --[suffixed expr end]
             = --[var list end]
             --[expression list start]
               --[suffixed expr start] number
                --[primary start] number
                  sum --local symbol number 
                --[primary end]
               --[suffixed expr end]
             --[expression list end]
            --[expression statement end]
         end
      end
      return
        --[suffixed expr start] table
         --[primary start] table
           x --local symbol table 
         --[primary end]
        --[suffixed expr end]
    end
  return
    --[suffixed expr start] any
     --[primary start] any
       matmul --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
function()
   matmul --global symbol any 
   =
    function(
      a --local symbol table 
     ,
      b --local symbol table 
    )
    --locals  a, b, m, n, p, x, c, i, xi, j, sum, ai, cj, k
      --[expression statement start]
       --[expression list start]
         --[suffixed expr start] any
          --[primary start] any
            assert --global symbol any 
          --[primary end]
          --[suffix list start]
            --[function call start] any
             (
               --[binary expr start] any
                --[unary expr start] integer
                @integer
                 --[suffixed expr start] any
                  --[primary start] any
                   --[unary expr start] any
                   #
                    --[suffixed expr start] any
                     --[primary start] table
                       a --local symbol table 
                     --[primary end]
                     --[suffix list start]
                       --[Y index start] any
                        [
                         1
                        ]
                       --[Y index end]
                     --[suffix list end]
                    --[suffixed expr end]
                   --[unary expr end]
                  --[primary end]
                 --[suffixed expr end]
                --[unary expr end]
               ==
                --[unary expr start] any
                #
                 --[suffixed expr start] table
                  --[primary start] table
                    b --local symbol table 
                  --[primary end]
                 --[suffixed expr end]
                --[unary expr end]
               --[binary expr end]
             )
            --[function call end]
          --[suffix list end]
         --[suffixed expr end]
       --[expression list end]
      --[expression statement end]
      local
      --[symbols]
        m --local symbol integer 
       ,
        n --local symbol integer 
       ,
        p --local symbol integer 
       ,
        x --local symbol table 
      --[expressions]
        --[unary expr start] any
        #
         --[suffixed expr start] table
          --[primary start] table
            a --local symbol table 
          --[primary end]
         --[suffixed expr end]
        --[unary expr end]
       ,
        --[unary expr start] any
        #
         --[suffixed expr start] any
          --[primary start] table
            a --local symbol table 
          --[primary end]
          --[suffix list start]
            --[Y index start] any
             [
              1
             ]
            --[Y index end]
          --[suffix list end]
         --[suffixed expr end]
        --[unary expr end]
       ,
        --[unary expr start] any
        #
         --[suffixed expr start] any
          --[primary start] table
            b --local symbol table 
          --[primary end]
          --[suffix list start]
            --[Y index start] any
             [
              1
             ]
            --[Y index end]
          --[suffix list end]
         --[suffixed expr end]
        --[unary expr end]
       ,
        { --[table constructor start] table
        } --[table constructor end]
      local
      --[symbols]
        c --local symbol table 
      --[expressions]
        --[suffixed expr start] any
         --[primary start] any
           matrix --global symbol any 
         --[primary end]
         --[suffix list start]
           --[field selector start] any
            .
             'T'
           --[field selector end]
           --[function call start] any
            (
              --[suffixed expr start] table
               --[primary start] table
                 b --local symbol table 
               --[primary end]
              --[suffixed expr end]
            )
           --[function call end]
         --[suffix list end]
        --[suffixed expr end]
      for
        i --local symbol integer 
      =
        1
       ,
        --[suffixed expr start] integer
         --[primary start] integer
           m --local symbol integer 
         --[primary end]
        --[suffixed expr end]
      do
         local
         --[symbols]
           xi --local symbol number[] 
         --[expressions]
           --[suffixed expr start] any
            --[primary start] any
              table --global symbol any 
            --[primary end]
            --[suffix list start]
              --[field selector start] any
               .
                'numarray'
              --[field selector end]
              --[function call start] any
               (
                 --[suffixed expr start] integer
                  --[primary start] integer
                    p --local symbol integer 
                  --[primary end]
                 --[suffixed expr end]
                ,
                 0.0000000000000000
               )
              --[function call end]
            --[suffix list end]
           --[suffixed expr end]
         --[expression statement start]
          --[var list start]
            --[suffixed expr start] any
             --[primary start] table
               x --local symbol table 
             --[primary end]
             --[suffix list start]
               --[Y index start] any
                [
                 --[suffixed expr start] integer
                  --[primary start] integer
                    i --local symbol integer 
                  --[primary end]
                 --[suffixed expr end]
                ]
               --[Y index end]
             --[suffix list end]
            --[suffixed expr end]
          = --[var list end]
          --[expression list start]
            --[suffixed expr start] number[]
             --[primary start] number[]
               xi --local symbol number[] 
             --[primary end]
            --[suffixed expr end]
          --[expression list end]
         --[expression statement end]
         for
           j --local symbol integer 
         =
           1
          ,
           --[suffixed expr start] integer
            --[primary start] integer
              p --local symbol integer 
            --[primary end]
           --[suffixed expr end]
         do
            local
            --[symbols]
              sum --local symbol number 
             ,
              ai --local symbol number[] 
             ,
              cj --local symbol number[] 
            --[expressions]
              0.0000000000000000
             ,
              --[unary expr start] number[]
              @number[]
               --[suffixed expr start] any
                --[primary start] any
                 --[suffixed expr start] any
                  --[primary start] table
                    a --local symbol table 
                  --[primary end]
                  --[suffix list start]
                    --[Y index start] any
                     [
                      --[suffixed expr start] integer
                       --[primary start] integer
                         i --local symbol integer 
                       --[primary end]
                      --[suffixed expr end]
                     ]
                    --[Y index end]
                  --[suffix list end]
                 --[suffixed expr end]
                --[primary end]
               --[suffixed expr end]
              --[unary expr end]
             ,
              --[unary expr start] number[]
              @number[]
               --[suffixed expr start] any
                --[primary start] any
                 --[suffixed expr start] any
                  --[primary start] table
                    c --local symbol table 
                  --[primary end]
                  --[suffix list start]
                    --[Y index start] any
                     [
                      --[suffixed expr start] integer
                       --[primary start] integer
                         j --local symbol integer 
                       --[primary end]
                      --[suffixed expr end]
                     ]
                    --[Y index end]
                  --[suffix list end]
                 --[suffixed expr end]
                --[primary end]
               --[suffixed expr end]
              --[unary expr end]
            for
              k --local symbol integer 
            =
              1
             ,
              --[suffixed expr start] integer
               --[primary start] integer
                 n --local symbol integer 
               --[primary end]
              --[suffixed expr end]
            do
               --[expression statement start]
                --[var list start]
                  --[suffixed expr start] number
                   --[primary start] number
                     sum --local symbol number 
                   --[primary end]
                  --[suffixed expr end]
                = --[var list end]
                --[expression list start]
                  --[binary expr start] number
                   --[suffixed expr start] number
                    --[primary start] number
                      sum --local symbol number 
                    --[primary end]
                   --[suffixed expr end]
                  +
                   --[binary expr start] number
                    --[suffixed expr start] number
                     --[primary start] number[]
                       ai --local symbol number[] 
                     --[primary end]
                     --[suffix list start]
                       --[Y index start] number
                        [
                         --[suffixed expr start] integer
                          --[primary start] integer
                            k --local symbol integer 
                          --[primary end]
                         --[suffixed expr end]
                        ]
                       --[Y index end]
                     --[suffix list end]
                    --[suffixed expr end]
                   *
                    --[suffixed expr start] number
                     --[primary start] number[]
                       cj --local symbol number[] 
                     --[primary end]
                     --[suffix list start]
                       --[Y index start] number
                        [
                         --[suffixed expr start] integer
                          --[primary start] integer
                            k --local symbol integer 
                          --[primary end]
                         --[suffixed expr end]
                        ]
                       --[Y index end]
                     --[suffix list end]
                    --[suffixed expr end]
                   --[binary expr end]
                  --[binary expr end]
                --[expression list end]
               --[expression statement end]
            end
            --[expression statement start]
             --[var list start]
               --[suffixed expr start] number
                --[primary start] number[]
                  xi --local symbol number[] 
                --[primary end]
                --[suffix list start]
                  --[Y index start] number
                   [
                    --[suffixed expr start] integer
                     --[primary start] integer
                       j --local symbol integer 
                     --[primary end]
                    --[suffixed expr end]
                   ]
                  --[Y index end]
                --[suffix list end]
               --[suffixed expr end]
             = --[var list end]
             --[expression list start]
               --[suffixed expr start] number
                --[primary start] number
                  sum --local symbol number 
                --[primary end]
               --[suffixed expr end]
             --[expression list end]
            --[expression statement end]
         end
      end
      return
        --[suffixed expr start] table
         --[primary start] table
           x --local symbol table 
         --[primary end]
        --[suffixed expr end]
    end
  return
    --[suffixed expr start] any
     --[primary start] any
       matmul --global symbol any 
     --[primary end]
    --[suffixed expr end]
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(1)}
	STOREGLOBAL {matmul, T(1)}
	LOADGLOBAL {matmul} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	TOTABLE {local(a, 0)}
	TOTABLE {local(b, 1)}
	LOADGLOBAL {assert} {T(0)}
	TGETik {local(a, 0), 1 Kint(0)} {T(1)}
	LEN {T(1)} {T(2)}
	TOINT {T(2)}
	LEN {local(b, 1)} {T(3)}
	EQ {T(2), T(3)} {T(4)}
	CALL {T(0), T(4)} {T(0..)}
	LEN {local(a, 0)} {T(4)}
	TGETik {local(a, 0), 1 Kint(0)} {T(3)}
	LEN {T(3)} {T(2)}
	TGETik {local(b, 1), 1 Kint(0)} {T(5)}
	LEN {T(5)} {T(6)}
	NEWTABLE {T(7)}
	MOV {T(7)} {local(x, 5)}
	MOV {T(6)} {local(p, 4)}
	MOV {T(2)} {local(n, 3)}
	MOV {T(4)} {local(m, 2)}
	LOADGLOBAL {matrix} {T(4)}
	GETsk {T(4), 'T' Ks(1)} {T(2)}
	CALL {T(2), local(b, 1)} {T(2..)}
	MOV {T(2[2..])} {local(c, 6)}
	MOV {1 Kint(0)} {Tint(0)}
	MOV {local(m, 2)} {Tint(1)}
	MOV {1 Kint(0)} {Tint(2)}
	LIii {0 Kint(2), Tint(2)} {Tint(3)}
	SUBii {Tint(0), Tint(2)} {Tint(0)}
	BR {L2}
L1 (exit)
L2
	ADDii {Tint(0), Tint(2)} {Tint(0)}
	CBR {Tint(3)} {L3, L4}
L3
	LEii {Tint(1), Tint(0)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L4
	LIii {Tint(0), Tint(1)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L5
	MOV {Tint(0)} {local(i, 7)}
	LOADGLOBAL {table} {T(6)}
	GETsk {T(6), 'numarray' Ks(3)} {T(7)}
	CALL {T(7), local(p, 4), 0 Kint(2)} {T(7..)}
	MOV {T(7[7..])} {local(xi, 8)}
	TPUTik {local(x, 5), local(i, 7), local(xi, 8)}
	MOV {1 Kint(0)} {Tint(5)}
	MOV {local(p, 4)} {Tint(6)}
	MOV {1 Kint(0)} {Tint(7)}
	LIii {0 Kint(2), Tint(7)} {Tint(8)}
	SUBii {Tint(5), Tint(7)} {Tint(5)}
	BR {L7}
L6
	RET {local(x, 5)} {L1}
L7
	ADDii {Tint(5), Tint(7)} {Tint(5)}
	CBR {Tint(8)} {L8, L9}
L8
	LEii {Tint(6), Tint(5)} {Tint(9)}
	CBR {Tint(9)} {L11, L10}
L9
	LIii {Tint(5), Tint(6)} {Tint(9)}
	CBR {Tint(9)} {L11, L10}
L10
	MOV {Tint(5)} {local(j, 9)}
	TGETik {local(a, 0), local(i, 7)} {T(8)}
	TOFARRAY {T(8)}
	TGETik {local(c, 6), local(j, 9)} {T(9)}
	TOFARRAY {T(9)}
	MOV {T(9)} {local(cj, 12)}
	MOV {T(8)} {local(ai, 11)}
	MOV {0 Kint(2)} {local(sum, 10)}
	MOV {1 Kint(0)} {Tint(10)}
	MOV {local(n, 3)} {Tint(11)}
	MOV {1 Kint(0)} {Tint(12)}
	LIii {0 Kint(2), Tint(12)} {Tint(13)}
	SUBii {Tint(10), Tint(12)} {Tint(10)}
	BR {L12}
L11
	BR {L2}
L12
	ADDii {Tint(10), Tint(12)} {Tint(10)}
	CBR {Tint(13)} {L13, L14}
L13
	LEii {Tint(11), Tint(10)} {Tint(14)}
	CBR {Tint(14)} {L16, L15}
L14
	LIii {Tint(10), Tint(11)} {Tint(14)}
	CBR {Tint(14)} {L16, L15}
L15
	MOV {Tint(10)} {local(k, 13)}
	FAGETik {local(ai, 11), local(k, 13)} {Tflt(0)}
	FAGETik {local(cj, 12), local(k, 13)} {Tflt(1)}
	MULff {Tflt(0), Tflt(1)} {Tflt(2)}
	ADDff {local(sum, 10), Tflt(2)} {Tflt(1)}
	MOV {Tflt(1)} {local(sum, 10)}
	BR {L12}
L16
	FAPUTfv {local(xi, 8), local(j, 9), local(sum, 10)}
	BR {L7}
return -3+4*5//2^3^2//9+4%10/3 == (-3)+(((4*5)//(2^(3^2)))//9)+((4%10)/3)
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] any
       -
        3
       --[unary expr end]
      +
       --[binary expr start] any
        --[binary expr start] any
         --[binary expr start] any
          4
         *
          5
         --[binary expr end]
        //
         --[binary expr start] any
          2
         ^
          --[binary expr start] any
           3
          ^
           2
          --[binary expr end]
         --[binary expr end]
        --[binary expr end]
       //
        9
       --[binary expr end]
      --[binary expr end]
     +
      --[binary expr start] any
       --[binary expr start] any
        4
       %
        10
       --[binary expr end]
      /
       3
      --[binary expr end]
     --[binary expr end]
    ==
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
         --[unary expr start] any
         -
          3
         --[unary expr end]
        --[primary end]
       --[suffixed expr end]
      +
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          --[suffixed expr start] any
           --[primary start] any
            --[binary expr start] any
             --[suffixed expr start] any
              --[primary start] any
               --[binary expr start] any
                4
               *
                5
               --[binary expr end]
              --[primary end]
             --[suffixed expr end]
            //
             --[suffixed expr start] any
              --[primary start] any
               --[binary expr start] any
                2
               ^
                --[suffixed expr start] any
                 --[primary start] any
                  --[binary expr start] any
                   3
                  ^
                   2
                  --[binary expr end]
                 --[primary end]
                --[suffixed expr end]
               --[binary expr end]
              --[primary end]
             --[suffixed expr end]
            --[binary expr end]
           --[primary end]
          --[suffixed expr end]
         //
          9
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      --[binary expr end]
     +
      --[suffixed expr start] any
       --[primary start] any
        --[binary expr start] any
         --[suffixed expr start] any
          --[primary start] any
           --[binary expr start] any
            4
           %
            10
           --[binary expr end]
          --[primary end]
         --[suffixed expr end]
        /
         3
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] integer
       -
        3
       --[unary expr end]
      +
       --[binary expr start] any
        --[binary expr start] any
         --[binary expr start] integer
          4
         *
          5
         --[binary expr end]
        //
         --[binary expr start] number
          2
         ^
          --[binary expr start] number
           3
          ^
           2
          --[binary expr end]
         --[binary expr end]
        --[binary expr end]
       //
        9
       --[binary expr end]
      --[binary expr end]
     +
      --[binary expr start] number
       --[binary expr start] integer
        4
       %
        10
       --[binary expr end]
      /
       3
      --[binary expr end]
     --[binary expr end]
    ==
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] integer
        --[primary start] integer
         --[unary expr start] integer
         -
          3
         --[unary expr end]
        --[primary end]
       --[suffixed expr end]
      +
       --[suffixed expr start] any
        --[primary start] any
         --[binary expr start] any
          --[suffixed expr start] any
           --[primary start] any
            --[binary expr start] any
             --[suffixed expr start] integer
              --[primary start] integer
               --[binary expr start] integer
                4
               *
                5
               --[binary expr end]
              --[primary end]
             --[suffixed expr end]
            //
             --[suffixed expr start] number
              --[primary start] number
               --[binary expr start] number
                2
               ^
                --[suffixed expr start] number
                 --[primary start] number
                  --[binary expr start] number
                   3
                  ^
                   2
                  --[binary expr end]
                 --[primary end]
                --[suffixed expr end]
               --[binary expr end]
              --[primary end]
             --[suffixed expr end]
            --[binary expr end]
           --[primary end]
          --[suffixed expr end]
         //
          9
         --[binary expr end]
        --[primary end]
       --[suffixed expr end]
      --[binary expr end]
     +
      --[suffixed expr start] number
       --[primary start] number
        --[binary expr start] number
         --[suffixed expr start] integer
          --[primary start] integer
           --[binary expr start] integer
            4
           %
            10
           --[binary expr end]
          --[primary end]
         --[suffixed expr end]
        /
         3
        --[binary expr end]
       --[primary end]
      --[suffixed expr end]
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	UNMi {3 Kint(0)} {Tint(0)}
	MULii {4 Kint(1), 5 Kint(2)} {Tint(1)}
	POW {3 Kint(0), 2 Kint(3)} {Tflt(0)}
	POW {2 Kint(3), Tflt(0)} {Tflt(1)}
	IDIV {Tint(1), Tflt(1)} {T(0)}
	IDIV {T(0), 9 Kint(4)} {T(1)}
	ADD {Tint(0), T(1)} {T(0)}
	MOD {4 Kint(1), 10 Kint(5)} {Tint(0)}
	DIVii {Tint(0), 3 Kint(0)} {Tflt(1)}
	ADD {T(0), Tflt(1)} {T(1)}
	UNMi {3 Kint(0)} {Tint(0)}
	MULii {4 Kint(1), 5 Kint(2)} {Tint(1)}
	POW {3 Kint(0), 2 Kint(3)} {Tflt(1)}
	POW {2 Kint(3), Tflt(1)} {Tflt(0)}
	IDIV {Tint(1), Tflt(0)} {T(0)}
	IDIV {T(0), 9 Kint(4)} {T(2)}
	ADD {Tint(0), T(2)} {T(0)}
	MOD {4 Kint(1), 10 Kint(5)} {Tint(0)}
	DIVii {Tint(0), 3 Kint(0)} {Tflt(0)}
	ADD {T(0), Tflt(0)} {T(2)}
	EQ {T(1), T(2)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
return -3%5 == 2 and -3+5 == 2

function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] any
       -
        3
       --[unary expr end]
      %
       5
      --[binary expr end]
     ==
      2
     --[binary expr end]
    and
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] any
       -
        3
       --[unary expr end]
      +
       5
      --[binary expr end]
     ==
      2
     --[binary expr end]
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] boolean
      --[binary expr start] integer
       --[unary expr start] integer
       -
        3
       --[unary expr end]
      %
       5
      --[binary expr end]
     ==
      2
     --[binary expr end]
    and
     --[binary expr start] boolean
      --[binary expr start] integer
       --[unary expr start] integer
       -
        3
       --[unary expr end]
      +
       5
      --[binary expr end]
     ==
      2
     --[binary expr end]
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	UNMi {3 Kint(0)} {Tint(0)}
	MOD {Tint(0), 5 Kint(1)} {Tint(1)}
	EQii {Tint(1), 2 Kint(2)} {T(1)}
	MOV {T(1)} {T(0)}
	CBR {T(0)} {L2, L3}
L1 (exit)
L2
	UNMi {3 Kint(0)} {Tint(1)}
	ADDii {Tint(1), 5 Kint(1)} {Tint(0)}
	EQii {Tint(0), 2 Kint(2)} {T(1)}
	MOV {T(1)} {T(0)}
	BR {L3}
L3
	RET {T(0)} {L1}
return -((2.0^8 + -(-1)) % 8)/2 * 4 - 3

function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] any
       -
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           --[suffixed expr start] any
            --[primary start] any
             --[binary expr start] any
              --[binary expr start] any
               2.0000000000000000
              ^
               8
              --[binary expr end]
             +
              --[unary expr start] any
              -
               --[suffixed expr start] any
                --[primary start] any
                 --[unary expr start] any
                 -
                  1
                 --[unary expr end]
                --[primary end]
               --[suffixed expr end]
              --[unary expr end]
             --[binary expr end]
            --[primary end]
           --[suffixed expr end]
          %
           8
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       --[unary expr end]
      /
       2
      --[binary expr end]
     *
      4
     --[binary expr end]
    -
     3
    --[binary expr end]
end
function()
  return
    --[binary expr start] number
     --[binary expr start] number
      --[binary expr start] number
       --[unary expr start] number
       -
        --[suffixed expr start] number
         --[primary start] number
          --[binary expr start] number
           --[suffixed expr start] number
            --[primary start] number
             --[binary expr start] number
              --[binary expr start] number
               2.0000000000000000
              ^
               8
              --[binary expr end]
             +
              --[unary expr start] integer
              -
               --[suffixed expr start] integer
                --[primary start] integer
                 --[unary expr start] integer
                 -
                  1
                 --[unary expr end]
                --[primary end]
               --[suffixed expr end]
              --[unary expr end]
             --[binary expr end]
            --[primary end]
           --[suffixed expr end]
          %
           8
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       --[unary expr end]
      /
       2
      --[binary expr end]
     *
      4
     --[binary expr end]
    -
     3
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	POW {2.000000000000 Kflt(0), 8 Kint(1)} {Tflt(0)}
	UNMi {1 Kint(2)} {Tint(0)}
	UNMi {Tint(0)} {Tint(1)}
	ADDfi {Tflt(0), Tint(1)} {Tflt(1)}
	MOD {Tflt(1), 8 Kint(1)} {Tflt(0)}
	UNMf {Tflt(0)} {Tflt(1)}
	DIVfi {Tflt(1), 2.000000000000 Kflt(0)} {Tflt(2)}
	MULfi {Tflt(2), 4 Kint(3)} {Tflt(1)}
	SUBfi {Tflt(1), 3 Kint(4)} {Tflt(2)}
	RET {Tflt(2)} {L1}
L1 (exit)
return -((2^8 + -(-1)) % 8)//2 * 4 - 3

function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] any
       -
        --[suffixed expr start] any
         --[primary start] any
          --[binary expr start] any
           --[suffixed expr start] any
            --[primary start] any
             --[binary expr start] any
              --[binary expr start] any
               2
              ^
               8
              --[binary expr end]
             +
              --[unary expr start] any
              -
               --[suffixed expr start] any
                --[primary start] any
                 --[unary expr start] any
                 -
                  1
                 --[unary expr end]
                --[primary end]
               --[suffixed expr end]
              --[unary expr end]
             --[binary expr end]
            --[primary end]
           --[suffixed expr end]
          %
           8
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       --[unary expr end]
      //
       2
      --[binary expr end]
     *
      4
     --[binary expr end]
    -
     3
    --[binary expr end]
end
function()
  return
    --[binary expr start] any
     --[binary expr start] any
      --[binary expr start] any
       --[unary expr start] number
       -
        --[suffixed expr start] number
         --[primary start] number
          --[binary expr start] number
           --[suffixed expr start] number
            --[primary start] number
             --[binary expr start] number
              --[binary expr start] number
               2
              ^
               8
              --[binary expr end]
             +
              --[unary expr start] integer
              -
               --[suffixed expr start] integer
                --[primary start] integer
                 --[unary expr start] integer
                 -
                  1
                 --[unary expr end]
                --[primary end]
               --[suffixed expr end]
              --[unary expr end]
             --[binary expr end]
            --[primary end]
           --[suffixed expr end]
          %
           8
          --[binary expr end]
         --[primary end]
        --[suffixed expr end]
       --[unary expr end]
      //
       2
      --[binary expr end]
     *
      4
     --[binary expr end]
    -
     3
    --[binary expr end]
end
define Proc(0)
L0 (entry)
	POW {2 Kint(0), 8 Kint(1)} {Tflt(0)}
	UNMi {1 Kint(2)} {Tint(0)}
	UNMi {Tint(0)} {Tint(1)}
	ADDfi {Tflt(0), Tint(1)} {Tflt(1)}
	MOD {Tflt(1), 8 Kint(1)} {Tflt(0)}
	UNMf {Tflt(0)} {Tflt(1)}
	IDIV {Tflt(1), 2 Kint(0)} {T(0)}
	MUL {T(0), 4 Kint(3)} {T(1)}
	SUB {T(1), 3 Kint(4)} {T(0)}
	RET {T(0)} {L1}
L1 (exit)
local x
do
  local y = 12
  goto l1
  ::l2:: x = x + 1; goto l3
  ::l1:: x = y; goto l2
end
::l3:: ::l3_1:: assert(x == 13)
function()
--locals  x, y
  local
  --[symbols]
    x --local symbol any 
  do
    local
    --[symbols]
      y --local symbol any 
    --[expressions]
      12
    goto l1
    ::l2::
    --[expression statement start]
     --[var list start]
       --[suffixed expr start] any
        --[primary start] any
          x --local symbol any 
        --[primary end]
       --[suffixed expr end]
     = --[var list end]
     --[expression list start]
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           x --local symbol any 
         --[primary end]
        --[suffixed expr end]
       +
        1
       --[binary expr end]
     --[expression list end]
    --[expression statement end]
    goto l3
    ::l1::
    --[expression statement start]
     --[var list start]
       --[suffixed expr start] any
        --[primary start] any
          x --local symbol any 
        --[primary end]
       --[suffixed expr end]
     = --[var list end]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          y --local symbol any 
        --[primary end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
    goto l2
  end
  ::l3::
  ::l3_1::
  --[expression statement start]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        assert --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
           --[binary expr start] any
            --[suffixed expr start] any
             --[primary start] any
               x --local symbol any 
             --[primary end]
            --[suffixed expr end]
           ==
            13
           --[binary expr end]
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
function()
--locals  x, y
  local
  --[symbols]
    x --local symbol any 
  do
    local
    --[symbols]
      y --local symbol any 
    --[expressions]
      12
    goto l1
    ::l2::
    --[expression statement start]
     --[var list start]
       --[suffixed expr start] any
        --[primary start] any
          x --local symbol any 
        --[primary end]
       --[suffixed expr end]
     = --[var list end]
     --[expression list start]
       --[binary expr start] any
        --[suffixed expr start] any
         --[primary start] any
           x --local symbol any 
         --[primary end]
        --[suffixed expr end]
       +
        1
       --[binary expr end]
     --[expression list end]
    --[expression statement end]
    goto l3
    ::l1::
    --[expression statement start]
     --[var list start]
       --[suffixed expr start] any
        --[primary start] any
          x --local symbol any 
        --[primary end]
       --[suffixed expr end]
     = --[var list end]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          y --local symbol any 
        --[primary end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
    goto l2
  end
  ::l3::
  ::l3_1::
  --[expression statement start]
   --[expression list start]
     --[suffixed expr start] any
      --[primary start] any
        assert --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
           --[binary expr start] any
            --[suffixed expr start] any
             --[primary start] any
               x --local symbol any 
             --[primary end]
            --[suffixed expr end]
           ==
            13
           --[binary expr end]
         )
        --[function call end]
      --[suffix list end]
     --[suffixed expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	MOV {12 Kint(0)} {local(y, 1)}
	BR {L5}
L1 (exit)
L2
	BR {L3}
L3
	ADD {local(x, 0), 1 Kint(1)} {T(0)}
	MOV {T(0)} {local(x, 0)}
	BR {L7}
L4
	BR {L5}
L5
	MOV {local(y, 1)} {local(x, 0)}
	BR {L3}
L6
	BR {L7}
L7
	BR {L8}
L8
	LOADGLOBAL {assert} {T(0)}
	EQ {local(x, 0), 13 Kint(2)} {T(1)}
	CALL {T(0), T(1)} {T(0..)}
	BR {L1}
for i=1,10 do print(i) end
function()
--locals  i
  for
    i --local symbol any 
  =
    1
   ,
    10
  do
     --[expression statement start]
      --[expression list start]
        --[suffixed expr start] any
         --[primary start] any
           print --global symbol any 
         --[primary end]
         --[suffix list start]
           --[function call start] any
            (
              --[suffixed expr start] any
               --[primary start] any
                 i --local symbol any 
               --[primary end]
              --[suffixed expr end]
            )
           --[function call end]
         --[suffix list end]
        --[suffixed expr end]
      --[expression list end]
     --[expression statement end]
  end
end
function()
--locals  i
  for
    i --local symbol integer 
  =
    1
   ,
    10
  do
     --[expression statement start]
      --[expression list start]
        --[suffixed expr start] any
         --[primary start] any
           print --global symbol any 
         --[primary end]
         --[suffix list start]
           --[function call start] any
            (
              --[suffixed expr start] integer
               --[primary start] integer
                 i --local symbol integer 
               --[primary end]
              --[suffixed expr end]
            )
           --[function call end]
         --[suffix list end]
        --[suffixed expr end]
      --[expression list end]
     --[expression statement end]
  end
end
define Proc(0)
L0 (entry)
	MOV {1 Kint(0)} {Tint(0)}
	MOV {10 Kint(1)} {Tint(1)}
	MOV {1 Kint(0)} {Tint(2)}
	LIii {0 Kint(2), Tint(2)} {Tint(3)}
	SUBii {Tint(0), Tint(2)} {Tint(0)}
	BR {L2}
L1 (exit)
L2
	ADDii {Tint(0), Tint(2)} {Tint(0)}
	CBR {Tint(3)} {L3, L4}
L3
	LEii {Tint(1), Tint(0)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L4
	LIii {Tint(0), Tint(1)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L5
	MOV {Tint(0)} {local(i, 0)}
	LOADGLOBAL {print} {T(0)}
	CALL {T(0), local(i, 0)} {T(0..)}
	BR {L2}
L6
	BR {L1}
for i=10,1,-1 do print(i) end
function()
--locals  i
  for
    i --local symbol any 
  =
    10
   ,
    1
   ,
    --[unary expr start] any
    -
     1
    --[unary expr end]
  do
     --[expression statement start]
      --[expression list start]
        --[suffixed expr start] any
         --[primary start] any
           print --global symbol any 
         --[primary end]
         --[suffix list start]
           --[function call start] any
            (
              --[suffixed expr start] any
               --[primary start] any
                 i --local symbol any 
               --[primary end]
              --[suffixed expr end]
            )
           --[function call end]
         --[suffix list end]
        --[suffixed expr end]
      --[expression list end]
     --[expression statement end]
  end
end
function()
--locals  i
  for
    i --local symbol integer 
  =
    10
   ,
    1
   ,
    --[unary expr start] integer
    -
     1
    --[unary expr end]
  do
     --[expression statement start]
      --[expression list start]
        --[suffixed expr start] any
         --[primary start] any
           print --global symbol any 
         --[primary end]
         --[suffix list start]
           --[function call start] any
            (
              --[suffixed expr start] integer
               --[primary start] integer
                 i --local symbol integer 
               --[primary end]
              --[suffixed expr end]
            )
           --[function call end]
         --[suffix list end]
        --[suffixed expr end]
      --[expression list end]
     --[expression statement end]
  end
end
define Proc(0)
L0 (entry)
	MOV {10 Kint(0)} {Tint(0)}
	MOV {1 Kint(1)} {Tint(1)}
	UNMi {1 Kint(1)} {Tint(2)}
	MOV {Tint(2)} {Tint(3)}
	LIii {0 Kint(2), Tint(3)} {Tint(4)}
	SUBii {Tint(0), Tint(3)} {Tint(0)}
	BR {L2}
L1 (exit)
L2
	ADDii {Tint(0), Tint(3)} {Tint(0)}
	CBR {Tint(4)} {L3, L4}
L3
	LEii {Tint(1), Tint(0)} {Tint(5)}
	CBR {Tint(5)} {L6, L5}
L4
	LIii {Tint(0), Tint(1)} {Tint(5)}
	CBR {Tint(5)} {L6, L5}
L5
	MOV {Tint(0)} {local(i, 0)}
	LOADGLOBAL {print} {T(0)}
	CALL {T(0), local(i, 0)} {T(0..)}
	BR {L2}
L6
	BR {L1}
while true do print('forever') end
function()
  while
   true
  do
    --[expression statement start]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          print --global symbol any 
        --[primary end]
        --[suffix list start]
          --[function call start] any
           (
             'forever'
           )
          --[function call end]
        --[suffix list end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
  end
end
function()
  while
   true
  do
    --[expression statement start]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          print --global symbol any 
        --[primary end]
        --[suffix list start]
          --[function call start] any
           (
             'forever'
           )
          --[function call end]
        --[suffix list end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
  end
end
define Proc(0)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	CBR {true} {L3, L4}
L3
	LOADGLOBAL {print} {T(0)}
	CALL {T(0), 'forever' Ks(0)} {T(0..)}
	BR {L2}
L4
	BR {L1}
repeat print('forever') brek until true
function()
  repeat
    --[expression statement start]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          print --global symbol any 
        --[primary end]
        --[suffix list start]
          --[function call start] any
           (
             'forever'
           )
          --[function call end]
        --[suffix list end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
    --[expression statement start]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          brek --global symbol any 
        --[primary end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
  until
   true
  --[repeat end]
end
function()
  repeat
    --[expression statement start]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          print --global symbol any 
        --[primary end]
        --[suffix list start]
          --[function call start] any
           (
             'forever'
           )
          --[function call end]
        --[suffix list end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
    --[expression statement start]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          brek --global symbol any 
        --[primary end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
  until
   true
  --[repeat end]
end
define Proc(0)
L0 (entry)
	BR {L3}
L1 (exit)
L2
	CBR {true} {L3, L4}
L3
	LOADGLOBAL {print} {T(0)}
	CALL {T(0), 'forever' Ks(0)} {T(0..)}
	LOADGLOBAL {brek} {T(1)}
	BR {L2}
L4
	BR {L1}
repeat print('forever') break until true return
function()
  repeat
    --[expression statement start]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          print --global symbol any 
        --[primary end]
        --[suffix list start]
          --[function call start] any
           (
             'forever'
           )
          --[function call end]
        --[suffix list end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
    goto break
  until
   true
  --[repeat end]
  return
end
function()
  repeat
    --[expression statement start]
     --[expression list start]
       --[suffixed expr start] any
        --[primary start] any
          print --global symbol any 
        --[primary end]
        --[suffix list start]
          --[function call start] any
           (
             'forever'
           )
          --[function call end]
        --[suffix list end]
       --[suffixed expr end]
     --[expression list end]
    --[expression statement end]
    goto break
  until
   true
  --[repeat end]
  return
end
define Proc(0)
L0 (entry)
	BR {L3}
L1 (exit)
L2
	CBR {true} {L3, L4}
L3
	LOADGLOBAL {print} {T(0)}
	CALL {T(0), 'forever' Ks(0)} {T(0..)}
	BR {L4}
L4
	RET {L1}
L5
	BR {L2}
for i =1,10 do if i == 2 then break end end return
function()
--locals  i
  for
    i --local symbol any 
  =
    1
   ,
    10
  do
     if
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
          i --local symbol any 
        --[primary end]
       --[suffixed expr end]
      ==
       2
      --[binary expr end]
     then
       goto break
     end
  end
  return
end
function()
--locals  i
  for
    i --local symbol integer 
  =
    1
   ,
    10
  do
     if
      --[binary expr start] boolean
       --[suffixed expr start] integer
        --[primary start] integer
          i --local symbol integer 
        --[primary end]
       --[suffixed expr end]
      ==
       2
      --[binary expr end]
     then
       goto break
     end
  end
  return
end
define Proc(0)
L0 (entry)
	MOV {1 Kint(0)} {Tint(0)}
	MOV {10 Kint(1)} {Tint(1)}
	MOV {1 Kint(0)} {Tint(2)}
	LIii {0 Kint(2), Tint(2)} {Tint(3)}
	SUBii {Tint(0), Tint(2)} {Tint(0)}
	BR {L2}
L1 (exit)
L2
	ADDii {Tint(0), Tint(2)} {Tint(0)}
	CBR {Tint(3)} {L3, L4}
L3
	LEii {Tint(1), Tint(0)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L4
	LIii {Tint(0), Tint(1)} {Tint(4)}
	CBR {Tint(4)} {L6, L5}
L5
	MOV {Tint(0)} {local(i, 0)}
	BR {L7}
L6
	RET {L1}
L7
	EQii {local(i, 0), 2 Kint(3)} {T(0)}
	CBR {T(0)} {L8, L9}
L8
	BR {L6}
L9
	BR {L2}
L10
	BR {L9}
local msgs = {}
function Message (m)
  if not _nomsg then
    print(m)
    msgs[#msgs+1] = string.sub(m, 3, -3)
  end
end

function()
--locals  msgs
  local
  --[symbols]
    msgs --local symbol any 
  --[expressions]
    { --[table constructor start] table
    } --[table constructor end]
   Message --global symbol any 
   =
    function(
      m --local symbol any 
    )
    --locals  m
    --upvalues  msgs
      if
       --[unary expr start] any
       not
        --[suffixed expr start] any
         --[primary start] any
           _nomsg --global symbol any 
         --[primary end]
        --[suffixed expr end]
       --[unary expr end]
      then
        --[expression statement start]
         --[expression list start]
           --[suffixed expr start] any
            --[primary start] any
              print --global symbol any 
            --[primary end]
            --[suffix list start]
              --[function call start] any
               (
                 --[suffixed expr start] any
                  --[primary start] any
                    m --local symbol any 
                  --[primary end]
                 --[suffixed expr end]
               )
              --[function call end]
            --[suffix list end]
           --[suffixed expr end]
         --[expression list end]
        --[expression statement end]
        --[expression statement start]
         --[var list start]
           --[suffixed expr start] any
            --[primary start] any
              msgs --upvalue any 
            --[primary end]
            --[suffix list start]
              --[Y index start] any
               [
                --[binary expr start] any
                 --[unary expr start] any
                 #
                  --[suffixed expr start] any
                   --[primary start] any
                     msgs --upvalue any 
                   --[primary end]
                  --[suffixed expr end]
                 --[unary expr end]
                +
                 1
                --[binary expr end]
               ]
              --[Y index end]
            --[suffix list end]
           --[suffixed expr end]
         = --[var list end]
         --[expression list start]
           --[suffixed expr start] any
            --[primary start] any
              string --global symbol any 
            --[primary end]
            --[suffix list start]
              --[field selector start] any
               .
                'sub'
              --[field selector end]
              --[function call start] any
               (
                 --[suffixed expr start] any
                  --[primary start] any
                    m --local symbol any 
                  --[primary end]
                 --[suffixed expr end]
                ,
                 3
                ,
                 --[unary expr start] any
                 -
                  3
                 --[unary expr end]
               )
              --[function call end]
            --[suffix list end]
           --[suffixed expr end]
         --[expression list end]
        --[expression statement end]
      end
    end
end
function()
--locals  msgs
  local
  --[symbols]
    msgs --local symbol any 
  --[expressions]
    { --[table constructor start] table
    } --[table constructor end]
   Message --global symbol any 
   =
    function(
      m --local symbol any 
    )
    --locals  m
    --upvalues  msgs
      if
       --[unary expr start] any
       not
        --[suffixed expr start] any
         --[primary start] any
           _nomsg --global symbol any 
         --[primary end]
        --[suffixed expr end]
       --[unary expr end]
      then
        --[expression statement start]
         --[expression list start]
           --[suffixed expr start] any
            --[primary start] any
              print --global symbol any 
            --[primary end]
            --[suffix list start]
              --[function call start] any
               (
                 --[suffixed expr start] any
                  --[primary start] any
                    m --local symbol any 
                  --[primary end]
                 --[suffixed expr end]
               )
              --[function call end]
            --[suffix list end]
           --[suffixed expr end]
         --[expression list end]
        --[expression statement end]
        --[expression statement start]
         --[var list start]
           --[suffixed expr start] any
            --[primary start] any
              msgs --upvalue any 
            --[primary end]
            --[suffix list start]
              --[Y index start] any
               [
                --[binary expr start] any
                 --[unary expr start] any
                 #
                  --[suffixed expr start] any
                   --[primary start] any
                     msgs --upvalue any 
                   --[primary end]
                  --[suffixed expr end]
                 --[unary expr end]
                +
                 1
                --[binary expr end]
               ]
              --[Y index end]
            --[suffix list end]
           --[suffixed expr end]
         = --[var list end]
         --[expression list start]
           --[suffixed expr start] any
            --[primary start] any
              string --global symbol any 
            --[primary end]
            --[suffix list start]
              --[field selector start] any
               .
                'sub'
              --[field selector end]
              --[function call start] any
               (
                 --[suffixed expr start] any
                  --[primary start] any
                    m --local symbol any 
                  --[primary end]
                 --[suffixed expr end]
                ,
                 3
                ,
                 --[unary expr start] integer
                 -
                  3
                 --[unary expr end]
               )
              --[function call end]
            --[suffix list end]
           --[suffixed expr end]
         --[expression list end]
        --[expression statement end]
      end
    end
end
define Proc(0)
L0 (entry)
	NEWTABLE {T(0)}
	MOV {T(0)} {local(msgs, 0)}
	CLOSURE {Proc(1)} {T(1)}
	STOREGLOBAL {Message, T(1)}
	BR {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	BR {L2}
L1 (exit)
L2
	LOADGLOBAL {_nomsg} {T(0)}
	NOT {T(0)} {T(1)}
	CBR {T(1)} {L3, L4}
L3
	LOADGLOBAL {print} {T(2)}
	CALL {T(2), local(m, 0)} {T(2..)}
	LEN {Upval(0)} {T(3)}
	ADD {T(3), 1 Kint(0)} {T(4)}
	LOADGLOBAL {string} {T(5)}
	GETsk {T(5), 'sub' Ks(1)} {T(6)}
	UNMi {3 Kint(2)} {Tint(0)}
	CALL {T(6), local(m, 0), 3 Kint(2), Tint(0)} {T(6..)}
	PUT {Upval(0), T(4), T(6[6..])}
	BR {L4}
L4
	BR {L1}
_soft = rawget(_G, "_soft") or false
Z[1][2] = false or true
local _g
r()[a].name = _g and 'Dibyendu' or 'majumdar'
function()
--locals  _g
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        _soft --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
         rawget --global symbol any 
       --[primary end]
       --[suffix list start]
         --[function call start] any
          (
            --[suffixed expr start] any
             --[primary start] any
               _G --global symbol any 
             --[primary end]
            --[suffixed expr end]
           ,
            '_soft'
          )
         --[function call end]
       --[suffix list end]
      --[suffixed expr end]
     or
      false
     --[binary expr end]
   --[expression list end]
  --[expression statement end]
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        Z --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
        --[Y index start] any
         [
          2
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[binary expr start] any
      false
     or
      true
     --[binary expr end]
   --[expression list end]
  --[expression statement end]
  local
  --[symbols]
    _g --local symbol any 
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        r --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
        --[Y index start] any
         [
          --[suffixed expr start] any
           --[primary start] any
             a --global symbol any 
           --[primary end]
          --[suffixed expr end]
         ]
        --[Y index end]
        --[field selector start] any
         .
          'name'
        --[field selector end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
          _g --local symbol any 
        --[primary end]
       --[suffixed expr end]
      and
       'Dibyendu'
      --[binary expr end]
     or
      'majumdar'
     --[binary expr end]
   --[expression list end]
  --[expression statement end]
end
function()
--locals  _g
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        _soft --global symbol any 
      --[primary end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[binary expr start] any
      --[suffixed expr start] any
       --[primary start] any
         rawget --global symbol any 
       --[primary end]
       --[suffix list start]
         --[function call start] any
          (
            --[suffixed expr start] any
             --[primary start] any
               _G --global symbol any 
             --[primary end]
            --[suffixed expr end]
           ,
            '_soft'
          )
         --[function call end]
       --[suffix list end]
      --[suffixed expr end]
     or
      false
     --[binary expr end]
   --[expression list end]
  --[expression statement end]
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        Z --global symbol any 
      --[primary end]
      --[suffix list start]
        --[Y index start] any
         [
          1
         ]
        --[Y index end]
        --[Y index start] any
         [
          2
         ]
        --[Y index end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[binary expr start] any
      false
     or
      true
     --[binary expr end]
   --[expression list end]
  --[expression statement end]
  local
  --[symbols]
    _g --local symbol any 
  --[expression statement start]
   --[var list start]
     --[suffixed expr start] any
      --[primary start] any
        r --global symbol any 
      --[primary end]
      --[suffix list start]
        --[function call start] any
         (
         )
        --[function call end]
        --[Y index start] any
         [
          --[suffixed expr start] any
           --[primary start] any
             a --global symbol any 
           --[primary end]
          --[suffixed expr end]
         ]
        --[Y index end]
        --[field selector start] any
         .
          'name'
        --[field selector end]
      --[suffix list end]
     --[suffixed expr end]
   = --[var list end]
   --[expression list start]
     --[binary expr start] any
      --[binary expr start] any
       --[suffixed expr start] any
        --[primary start] any
          _g --local symbol any 
        --[primary end]
       --[suffixed expr end]
      and
       'Dibyendu'
      --[binary expr end]
     or
      'majumdar'
     --[binary expr end]
   --[expression list end]
  --[expression statement end]
end
define Proc(0)
L0 (entry)
	LOADGLOBAL {rawget} {T(2)}
	LOADGLOBAL {_G} {T(3)}
	CALL {T(2), T(3), '_soft' Ks(0)} {T(2..)}
	MOV {T(2..)} {T(1)}
	CBR {T(1)} {L3, L2}
L1 (exit)
L2
	MOV {false} {T(1)}
	BR {L3}
L3
	STOREGLOBAL {_soft, T(1)}
	LOADGLOBAL {Z} {T(1)}
	GETik {T(1), 1 Kint(1)} {T(0)}
	MOV {false} {T(3)}
	CBR {T(3)} {L5, L4}
L4
	MOV {true} {T(3)}
	BR {L5}
L5
	PUTik {T(0), 2 Kint(2), T(3)}
	LOADGLOBAL {r} {T(3)}
	CALL {T(3)} {T(3)}
	LOADGLOBAL {a} {T(2)}
	GET {T(3), T(2)} {T(4)}
	MOV {local(_g, 0)} {T(7)}
	CBR {T(7)} {L8, L9}
L6
	MOV {'majumdar' Ks(5)} {T(6)}
	BR {L7}
L7
	PUTsk {T(4), 'name' Ks(3), T(6)}
	BR {L1}
L8
	MOV {'Dibyendu' Ks(4)} {T(7)}
	BR {L9}
L9
	MOV {T(7)} {T(6)}
	CBR {T(6)} {L7, L6}
function foo(bar: integer[], zee: number[], ...) end
function()
   foo --global symbol any 
   =
    function(
      bar --local symbol integer[] 
     ,
      zee --local symbol number[] 
    )
    --locals  bar, zee
    end
end
function()
   foo --global symbol any 
   =
    function(
      bar --local symbol integer[] 
     ,
      zee --local symbol number[] 
    )
    --locals  bar, zee
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(1)}
	STOREGLOBAL {foo, T(1)}
	BR {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	TOIARRAY {local(bar, 0)}
	TOFARRAY {local(zee, 1)}
	BR {L1}
L1 (exit)
function foo(bar: number, zee: string) end
function()
   foo --global symbol any 
   =
    function(
      bar --local symbol number 
     ,
      zee --local symbol string 
    )
    --locals  bar, zee
    end
end
function()
   foo --global symbol any 
   =
    function(
      bar --local symbol number 
     ,
      zee --local symbol string 
    )
    --locals  bar, zee
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(1)}
	STOREGLOBAL {foo, T(1)}
	BR {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	TOFLT {local(bar, 0)}
	TOSTRING {local(zee, 1)}
	BR {L1}
L1 (exit)
function foo(bar: closure, zee: My.User.Type) end
function()
   foo --global symbol any 
   =
    function(
      bar --local symbol closure 
     ,
      zee --local symbol userdata My.User.Type
    )
    --locals  bar, zee
    end
end
function()
   foo --global symbol any 
   =
    function(
      bar --local symbol closure 
     ,
      zee --local symbol userdata My.User.Type
    )
    --locals  bar, zee
    end
end
define Proc(0)
L0 (entry)
	CLOSURE {Proc(1)} {T(1)}
	STOREGLOBAL {foo, T(1)}
	BR {L1}
L1 (exit)
define Proc(1)
L0 (entry)
	TOCLOSURE {local(bar, 0)}
	TOTYPE {'My.User.Type' Ks(0)} {local(zee, 1)}
	BR {L1}
L1 (exit)
